
<!DOCTYPE html>
<html>
<head>
                  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EBGF4V165P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EBGF4V165P');
</script>
  <meta charset="utf-8">
  <title>Three.js Greybox Scene Build Date:2026-01-12 01:25:48</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 1000;
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <style>
    /* Mobile Overlay Containers */
    #mobile-controls {
        position: fixed;
        bottom: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; /* Let touches pass through to joystick */
        z-index: 999;
        display: none; /* Show only on mobile via JS */
    }

     #joystick-container {
        position: fixed;
        bottom: 40px;
        left: 40px;
        width: 150px;
        height: 150px;
        z-index: 1001;
        /* Important: Ensure this doesn't block touch-to-look on the rest of the screen */
        touch-action: none;
    }
    .mobile-btn {
        position: fixed;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: rgba(212, 106, 40, 0.4);
        border: 2px solid #d46a28;
        color: white;
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #btn-shoot { bottom: 120px; right: 40px; border-color: #a32e2e; background: rgba(163, 46, 46, 0.5); }
    #btn-interact { bottom: 40px; right: 40px; }

    /* Hide on desktop */
    @media (min-width: 992px) {
        #joystick-container, .mobile-btn { display: none; }
    }

    @media (max-width: 991px) { #mobile-controls { display: block; } }
</style>

<div id="mobile-controls">
    <div id="joystick-container"></div>
 <button id="btn-shoot" class="mobile-btn"><i class="bi bi-crosshair"></i></button>
<button id="btn-interact" class="mobile-btn"><i class="bi bi-hand-index-thumb"></i></button>
</div>  <div id="loading">Loading assets...</div>
  <div id="info">WASD to move | Mouse to look | Space to jump</div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://scottgrocott.github.io/metal_throne/assets/js/nipplejs.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>

        const JSON_URL = 'https://scottgrocott.github.io/metal_throne/assets/json/greybox_assets_dev.json';
    //gloabal controller state for mobile
let moveJoystick = null;
const mobileState = {
    forward: 0,
    side: 0,
    lookX: 0,
    lookY: 0,
    isMoving: false
};

// Movement Sensitivity
const moveSpeed = 0.15;
const lookSensitivity = 0.005;


    let scene, camera, renderer, loader;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    let canJump = true;
    
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    const PI_2 = Math.PI / 2;
    
    function init() {
//nipplejs joystick setup
  // 1. SAFE JOYSTICK INITIALIZATION
    const initJoystick = () => {
        const zone = document.getElementById('joystick-container');
        
        // Safety check: Is the library loaded and the div present?
        if (typeof nipplejs === 'undefined') {
            console.warn("NippleJS not found, retrying...");
            setTimeout(initJoystick, 100);
            return;
        }

        if (!zone) {
            console.error("Joystick container not found in DOM");
            return;
        }

        moveJoystick = nipplejs.create({
            zone: zone,
            mode: 'static',
            position: { left: '75px', top: '75px' },
            color: '#d46a28'
        });

        moveJoystick.on('move', (evt, data) => {
            mobileState.isMoving = true;
            mobileState.forward = data.vector.y;
            mobileState.side = data.vector.x;
        });

        moveJoystick.on('end', () => {
            mobileState.isMoving = false;
            mobileState.forward = 0;
            mobileState.side = 0;
        });
    };
    
    initJoystick();


      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 0, 750);
      
    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 0);
    
    // IMPORTANT: Three.js cameras need a rotation order for Euler manipulation
    camera.rotation.order = 'YXZ'; 
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xbbbbbb);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(1, 1, 0);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Ground
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC8A4 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // GLTF Loader
      loader = new THREE.GLTFLoader();
      
      // Controls
      setupControls();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      // Load scene data
      loadScene();
    }
    
    function setupControls() {
      document.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = true; break;
          case 'KeyS': moveBackward = true; break;
          case 'KeyA': moveLeft = true; break;
          case 'KeyD': moveRight = true; break;
          case 'Space': if (canJump) velocity.y += 5; canJump = false; break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = false; break;
          case 'KeyS': moveBackward = false; break;
          case 'KeyA': moveLeft = false; break;
          case 'KeyD': moveRight = false; break;
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === document.body) {
          euler.setFromQuaternion(camera.quaternion);
          euler.y -= e.movementX * 0.002;
          euler.x -= e.movementY * 0.002;
          euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
          camera.quaternion.setFromEuler(euler);
        }
      });
      
      document.body.addEventListener('click', () => {
        document.body.requestPointerLock();
      });
    }
    
    async function loadScene() {
      try {
        const response = await fetch(JSON_URL);
        const data = await response.json();
        
        let loadedCount = 0;
        const totalAssets = data.buildings.length;
        
        // Load buildings
        data.buildings.forEach((building, index) => {
          const modelId = building.model.replace('#', '').replace('glb', '');
          const asset = data.assets.find(a => a.id === modelId + 'glb');
          
          if (asset) {
            loader.load(
              asset.src,
              (gltf) => {
                const model = gltf.scene;
// 1. Parse Position (Default to 0 0 0)
const posArr = building.position ? building.position.split(' ').map(Number) : [0, 0, 0];

// 2. Parse Scale (Defensive: if missing or "0 0 0", force to "1 1 1")
let scaleArr = [1, 1, 1]; // Default
if (building.scale && building.scale !== "0 0 0") {
    scaleArr = building.scale.split(' ').map(Number);
}

// 3. Parse Rotation (Default to 0 0 0)
const rotArr = building.rotation ? building.rotation.split(' ').map(Number) : [0, 0, 0];

//console.log(`Processing building: ${building.id} | Scale: ${scaleArr.join(' ')}`);

// Apply to Three.js Model
model.position.set(posArr[0], posArr[1], posArr[2]);

model.scale.set(scaleArr[0], scaleArr[1], scaleArr[2]);

// Convert Degrees from JSON/A-Frame logic to Radians for Three.js
model.rotation.set(
    THREE.MathUtils.degToRad(rotArr[0]),
    THREE.MathUtils.degToRad(rotArr[1]),
    THREE.MathUtils.degToRad(rotArr[2])
);

// Optional: Ensure the matrix updates for raycasting/physics
model.updateMatrixWorld();
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                scene.add(model);
                
                loadedCount++;
                updateLoadingProgress(loadedCount, totalAssets);
              },
              undefined,
              (error) => {
                console.error(`Error loading ${building.id}:`, error);
                loadedCount++;
                updateLoadingProgress(loadedCount, totalAssets);
              }
            );
          }
        });
        
        // Create tanks
        /*
        data.tanks.forEach((tank, index) => {
          const geometry = new THREE.CylinderGeometry(1, 1, 1, 32);
          const material = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
          const cylinder = new THREE.Mesh(geometry, material);
          
          const pos = tank.position.split(' ').map(Number);
          const scale = tank.scale.split(' ').map(Number);
          
          cylinder.position.set(pos[0], pos[1], pos[2]);
          cylinder.scale.set(scale[0], scale[1], scale[2]);
          cylinder.castShadow = true;
          cylinder.receiveShadow = true;
          
          scene.add(cylinder);
        });
        */
      } catch (error) {
        console.error('Error loading scene:', error);
        document.querySelector('#loading').textContent = 'Error loading scene';
      }
    }
    
    function updateLoadingProgress(loaded, total) {
      const loadingEl = document.querySelector('#loading');
      loadingEl.textContent = `Loading assets... ${loaded}/${total}`;
      
      if (loaded >= total) {
        setTimeout(() => {
          loadingEl.style.display = 'none';
        }, 500);
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
       updateMobileMovement(); 
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      
      velocity.x -= velocity.x * 4.0 * delta;
      velocity.z -= velocity.z * 4.0 * delta;
      velocity.y -= .2 * delta; // gravity
      
      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();
      
      if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;
      
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();
      
      const moveDirection = new THREE.Vector3();
      moveDirection.addScaledVector(forward, -velocity.z * delta);
      moveDirection.addScaledVector(right, -velocity.x * delta);
      
      camera.position.add(moveDirection);
      camera.position.y += velocity.y * delta;
      
      if (camera.position.y < 1.6) {
        velocity.y = 0;
        camera.position.y = 1.6;
        canJump = true;
      }
      
      prevTime = time;
      renderer.render(scene, camera);
    }
    
let lastTouchX = 0;
let lastTouchY = 0;

window.addEventListener('touchstart', (e) => {
    const touch = e.touches[0];
    lastTouchX = touch.pageX;
    lastTouchY = touch.pageY;
}, { passive: false });

window.addEventListener('touchmove', (e) => {
    // Only process look-around if the touch is NOT on the joystick zone
    if (e.target.id === 'joystick-zone' || e.target.closest('#joystick-zone')) return;

    const touch = e.touches[0];
    const movementX = touch.pageX - lastTouchX;
    const movementY = touch.pageY - lastTouchY;

    // Update camera rotation
    // Note: We rotate the camera's Y based on horizontal movement
    // and the camera's X based on vertical movement
    camera.rotation.y -= movementX * lookSensitivity;
    
    // Clamp vertical look to prevent flipping 180 degrees
    const newRotationX = camera.rotation.x - movementY * lookSensitivity;
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, newRotationX));

    lastTouchX = touch.pageX;
    lastTouchY = touch.pageY;
}, { passive: false });


 // This ensures nipple.js and all PHP-included HTML are ready
window.onload = () => {
    init();
    animate();
};

// 3. DEFENSIVE ACTION BUTTONS
// Wrap these in DOMContentLoaded to ensure the mobile_nav buttons exist
document.addEventListener('DOMContentLoaded', () => {
    const shootBtn = document.getElementById('btn-shoot');
    const interactBtn = document.getElementById('btn-interact');

    if (shootBtn) {
        shootBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            console.log("Mobile Shoot");
            // performShoot(); // Ensure this function is defined
        });
    }

    if (interactBtn) {
        interactBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            console.log("Mobile Interact");
            // checkInteraction(); // Ensure this function is defined
        });
    }
});


function updateMobileMovement() {
    if (!mobileState.isMoving) return;

    // 1. Get the camera's forward direction
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    
    // 2. Flatten the direction (so we don't fly if looking up)
    direction.y = 0;
    direction.normalize();

    // 3. Calculate the "Right" vector for strafing
    const sideVector = new THREE.Vector3();
    sideVector.crossVectors(camera.up, direction);

    // 4. Apply forward/backward movement
    camera.position.addScaledVector(direction, mobileState.forward * moveSpeed);
    
    // 5. Apply strafe movement
    camera.position.addScaledVector(sideVector, -mobileState.side * moveSpeed);
}

    // Mobile Joystick Setup
    /*
    var options = {
        zone: document.getElementById('joystick-zone'),
    };
    var manager = nipplejs.create(options);
*/

document.getElementById('btn-shoot').addEventListener('touchstart', (e) => {
    e.preventDefault();
    // Trigger your raycasting/shooting logic here
    console.log("Weapon Discharged");
    performShoot(); 
});

document.getElementById('btn-interact').addEventListener('touchstart', (e) => {
    e.preventDefault();
    // Trigger detonator pickup / door logic
    checkInteraction(); 
});
  </script>
</body>
</html>