<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Three.js Greybox Scene</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 1000;
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="loading">Loading assets...</div>
  <div id="info">WASD to move | Mouse to look | Space to jump</div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    //const JSON_URL = 'https://scottgrocott.github.io/metal_throne/assets/json/greybox_assets.json';
    const JSON_URL = 'http://localhost:81/metal_throne/assets/json/greybox_assets_dev.json';

    let scene, camera, renderer, loader;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let velocity = new THREE.Vector3();
    let direction = new THREE.Vector3();
    let prevTime = performance.now();
    let canJump = true;
    
    const euler = new THREE.Euler(0, 0, 0, 'YXZ');
    const PI_2 = Math.PI / 2;
    
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87CEEB);
      scene.fog = new THREE.Fog(0x87CEEB, 0, 750);
      
      // Camera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 1.6, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Lighting
      const ambientLight = new THREE.AmbientLight(0xbbbbbb);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
      directionalLight.position.set(1, 1, 0);
      directionalLight.castShadow = true;
      scene.add(directionalLight);
      
      // Ground
      const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
      const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x7BC8A4 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // GLTF Loader
      loader = new THREE.GLTFLoader();
      
      // Controls
      setupControls();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      // Load scene data
      loadScene();
    }
    
    function setupControls() {
      document.addEventListener('keydown', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = true; break;
          case 'KeyS': moveBackward = true; break;
          case 'KeyA': moveLeft = true; break;
          case 'KeyD': moveRight = true; break;
          case 'Space': if (canJump) velocity.y += 5; canJump = false; break;
        }
      });
      
      document.addEventListener('keyup', (e) => {
        switch (e.code) {
          case 'KeyW': moveForward = false; break;
          case 'KeyS': moveBackward = false; break;
          case 'KeyA': moveLeft = false; break;
          case 'KeyD': moveRight = false; break;
        }
      });
      
      document.addEventListener('mousemove', (e) => {
        if (document.pointerLockElement === document.body) {
          euler.setFromQuaternion(camera.quaternion);
          euler.y -= e.movementX * 0.002;
          euler.x -= e.movementY * 0.002;
          euler.x = Math.max(-PI_2, Math.min(PI_2, euler.x));
          camera.quaternion.setFromEuler(euler);
        }
      });
      
      document.body.addEventListener('click', () => {
        document.body.requestPointerLock();
      });
    }
    
    async function loadScene() {
      try {
        const response = await fetch(JSON_URL);
        const data = await response.json();
        
        let loadedCount = 0;
        const totalAssets = data.buildings.length;
        
        // Load buildings
        data.buildings.forEach((building, index) => {
          const modelId = building.model.replace('#', '').replace('glb', '');
          const asset = data.assets.find(a => a.id === modelId + 'glb');
          
          if (asset) {
            loader.load(
              asset.src,
              (gltf) => {
                const model = gltf.scene;
                const pos = building.position.split(' ').map(Number);
                console.log('Adding building:', building.id, 'at', pos);
                 if (building.id == 'green') {
                  pos[1] = 195.240;
                  console.log('Adjusted green position to:', pos);
                }
                model.position.set(pos[0], pos[1], pos[2]);
                model.traverse((child) => {
                  if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                  }
                });
                scene.add(model);
                
                loadedCount++;
                updateLoadingProgress(loadedCount, totalAssets);
              },
              undefined,
              (error) => {
                console.error(`Error loading ${building.id}:`, error);
                loadedCount++;
                updateLoadingProgress(loadedCount, totalAssets);
              }
            );
          }
        });
        
        // Create tanks
        data.tanks.forEach((tank, index) => {
          const geometry = new THREE.CylinderGeometry(1, 1, 1, 32);
          const material = new THREE.MeshLambertMaterial({ color: 0xC0C0C0 });
          const cylinder = new THREE.Mesh(geometry, material);
          
          const pos = tank.position.split(' ').map(Number);
          const scale = tank.scale.split(' ').map(Number);
          
          cylinder.position.set(pos[0], pos[1], pos[2]);
          cylinder.scale.set(scale[0], scale[1], scale[2]);
          cylinder.castShadow = true;
          cylinder.receiveShadow = true;
          
          scene.add(cylinder);
        });
        
      } catch (error) {
        console.error('Error loading scene:', error);
        document.querySelector('#loading').textContent = 'Error loading scene';
      }
    }
    
    function updateLoadingProgress(loaded, total) {
      const loadingEl = document.querySelector('#loading');
      loadingEl.textContent = `Loading assets... ${loaded}/${total}`;
      
      if (loaded >= total) {
        setTimeout(() => {
          loadingEl.style.display = 'none';
        }, 500);
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      
      velocity.x -= velocity.x * 4.0 * delta;
      velocity.z -= velocity.z * 4.0 * delta;
      velocity.y -= .8 * delta; // gravity
      
      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();
      
      if (moveForward || moveBackward) velocity.z -= direction.z * 40.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 40.0 * delta;
      
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      
      const right = new THREE.Vector3();
      right.crossVectors(forward, camera.up).normalize();
      
      const moveDirection = new THREE.Vector3();
      moveDirection.addScaledVector(forward, -velocity.z * delta);
      moveDirection.addScaledVector(right, -velocity.x * delta);
      
      camera.position.add(moveDirection);
      camera.position.y += velocity.y * delta;
      
      if (camera.position.y < 1.6) {
        velocity.y = 0;
        camera.position.y = 1.6;
        canJump = true;
      }
      
      prevTime = time;
      renderer.render(scene, camera);
    }
    
    init();
    animate();
  </script>
</body>
</html>