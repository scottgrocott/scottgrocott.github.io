
<!DOCTYPE html>
<html>
<head>
                  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-EBGF4V165P"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-EBGF4V165P');
</script>
  <meta charset="utf-8">
  <title>Babylon.js Greybox Scene Build Date:2026-01-12 01:26:35</title>
  <style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background-color: #000;
}

#renderCanvas {
    position: fixed; /* Takes the canvas out of the flow */
    top: 0;
    left: 0;
    width: 100vw;   /* Viewport Width */
    height: 100vh;  /* Viewport Height */
    display: block;
    touch-action: none;
    outline: none;
}
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 24px;
      z-index: 1000;
      text-align: center;
      background: rgba(0,0,0,0.7);
      padding: 20px;
      border-radius: 10px;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0,0,0,0.5);
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
    }
  </style>
</head>
<body>
  <style>
    /* Mobile Overlay Containers */
    #mobile-controls {
        position: fixed;
        bottom: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; /* Let touches pass through to joystick */
        z-index: 999;
        display: none; /* Show only on mobile via JS */
    }

     #joystick-container {
        position: fixed;
        bottom: 40px;
        left: 40px;
        width: 150px;
        height: 150px;
        z-index: 1001;
        /* Important: Ensure this doesn't block touch-to-look on the rest of the screen */
        touch-action: none;
    }
    .mobile-btn {
        position: fixed;
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background: rgba(212, 106, 40, 0.4);
        border: 2px solid #d46a28;
        color: white;
        z-index: 1001;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #btn-shoot { bottom: 120px; right: 40px; border-color: #a32e2e; background: rgba(163, 46, 46, 0.5); }
    #btn-interact { bottom: 40px; right: 40px; }

    /* Hide on desktop */
    @media (min-width: 992px) {
        #joystick-container, .mobile-btn { display: none; }
    }

    @media (max-width: 991px) { #mobile-controls { display: block; } }
</style>

<div id="mobile-controls">
    <div id="joystick-container"></div>
 <button id="btn-shoot" class="mobile-btn"><i class="bi bi-crosshair"></i></button>
<button id="btn-interact" class="mobile-btn"><i class="bi bi-hand-index-thumb"></i></button>
</div>  <canvas id="renderCanvas"></canvas>
  <div id="loading">Loading assets...</div>
  <div id="info">WASD to move | Mouse to look | Space to jump | Click to start</div>
  
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  
  <script>
          const JSON_URL = 'https://scottgrocott.github.io/metal_throne/assets/json/greybox_assets_dev.json';
         
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true,{ 
    adaptToDeviceRatio: true, 
    antialias: true 
});
engine.onResizeObservable.add(() => {
    // This ensures that when the simulation toggles, 
    // Babylon re-renders at the correct resolution
    scene.getEngine().resize();
});
    let scene, camera;
    
    const createScene = async () => {
      scene = new BABYLON.Scene(engine);
      scene.useRightHandedSystem = true;
      scene.clearColor = new BABYLON.Color3(0.529, 0.808, 0.922); // Sky blue
      scene.fogMode = BABYLON.Scene.FOGMODE_LINEAR;
      scene.fogColor = new BABYLON.Color3(0.529, 0.808, 0.922);
      scene.fogStart = 10000;
      scene.fogEnd = 75000;
      
/*
// Setup Virtual Joysticks
const leftJoystick = new BABYLON.VirtualJoystick(true); // Left side
leftJoystick.setJoystickSensibility(0.02);

scene.onBeforeRenderObservable.add(() => {
    if (leftJoystick.pressed) {
        const moveVec = leftJoystick.deltaPosition;
        // Apply movement to your camera/player
        camera.cameraDirection.x += moveVec.x * speed;
        camera.cameraDirection.z += moveVec.y * speed;
    }
});

// Use the FreeCamera/UniversalCamera - it has touch-rotate built in!
const camera = new BABYLON.UniversalCamera("MobileCam", new BABYLON.Vector3(0, 1.6, 0), scene);
camera.attachControl(canvas, true);
*/




      // Camera with collision
      camera = new BABYLON.UniversalCamera('camera', new BABYLON.Vector3(0, 1.6, 0), scene);
      camera.attachControl(canvas, true);
      camera.speed = 1;
      camera.angularSensibility = 2000;
      
      // Enable collision
      camera.checkCollisions = false;
      camera.applyGravity = false;
      camera.ellipsoid = new BABYLON.Vector3(1, 0.9, 1);
      scene.gravity = new BABYLON.Vector3(0, -0.15, 0);
      
      // WASD keys
      camera.keysUp.push(87); // W
      camera.keysDown.push(83); // S
      camera.keysLeft.push(65); // A
      camera.keysRight.push(68); // D
      
      // Lighting
      const ambientLight = new BABYLON.HemisphericLight('ambientLight', new BABYLON.Vector3(0, 1, 0), scene);
      ambientLight.intensity = 0.7;
      
      const directionalLight = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(-1, -2, -1), scene);
      directionalLight.position = new BABYLON.Vector3(20, 40, 20);
      directionalLight.intensity = 0.5;
      
      // Shadows
      const shadowGenerator = new BABYLON.ShadowGenerator(1024, directionalLight);
      shadowGenerator.useBlurExponentialShadowMap = true;
      shadowGenerator.blurKernel = 32;
      
      // Ground
      const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 10000, height: 10000 }, scene);
      ground.material = new BABYLON.StandardMaterial('groundMat', scene);
      ground.material.diffuseColor = new BABYLON.Color3(0.482, 0.784, 0.643); // Green
      ground.receiveShadows = true;
      ground.checkCollisions = true;
      //debug
      //scene.debugLayer.show();

      // Load scene data
      await loadSceneData(shadowGenerator);
      
      return scene;
    };
    
    const loadSceneData = async (shadowGenerator) => {
      try {
        const response = await fetch(JSON_URL);
        const data = await response.json();
        
        let loadedCount = 0;
        const totalAssets = data.buildings.length;
        
        // Load buildings
        const loadPromises = data.buildings.map((building) => {
          return new Promise((resolve) => {
            const modelId = building.model.replace('#', '').replace('glb', '');
            const asset = data.assets.find(a => a.id === modelId + 'glb');
            
            if (asset) {
BABYLON.SceneLoader.ImportMesh(
  '',
  '',
  asset.src,
  scene,
  (meshes) => {
const posArr = building.position ? building.position.split(' ').map(Number) : [0, 0, 0];
const rotArr = building.rotation ? building.rotation.split(' ').map(Number) : [0, 0, 0];

const root = meshes[0]; 
if (root) {
    // 1. Position now matches exactly (No - sign needed!)
    root.position = new BABYLON.Vector3(posArr[0], posArr[1], posArr[2]);

    // 2. Scale
    root.scaling = new BABYLON.Vector3(1, 1, 1); 

    // 3. Rotation: Nullify the glTF quaternion so .rotation works
    root.rotationQuaternion = null; 

    // 4. Set Euler Order to match Three.js (XYZ)
    // Babylon defaults to YXZ. We force XYZ to match your other engines.
    root.rotation = new BABYLON.Vector3(
        BABYLON.Tools.ToRadians(rotArr[0]),
        BABYLON.Tools.ToRadians(rotArr[1]),
        BABYLON.Tools.ToRadians(rotArr[2])
    );


    // Metadata for your Stealth Logic
    root.id = building.id;
    root.metadata = { class: building.class };
}

    // 2. Loop through ALL meshes for properties like Shadows and Collisions
    meshes.forEach((mesh) => {
      if (mesh) {
        // DO NOT set mesh.position here anymore
        
        mesh.checkCollisions = true;

        // Only add meshes with actual geometry to the shadow generator
        if (mesh.getClassName() === "Mesh" || mesh.getClassName() === "InstancedMesh") {
          if (mesh.material) {
            shadowGenerator.addShadowCaster(mesh);
            mesh.receiveShadows = true;
          }
        }
      }
    });

    loadedCount++;
    updateLoadingProgress(loadedCount, totalAssets);
    resolve();
  }
);
            } else {
              resolve();
            }
          });
        });
        
        // Create tanks
        /*
        data.tanks.forEach((tank, index) => {
          const pos = tank.position.split(' ').map(Number);
          const scale = tank.scale.split(' ').map(Number);
          
          const cylinder = BABYLON.MeshBuilder.CreateCylinder(
            `tank-${index}`,
            { height: 1, diameter: 2 },
            scene
          );
          
          cylinder.position = new BABYLON.Vector3(-pos[0], pos[1], -pos[2]);
          cylinder.scaling = new BABYLON.Vector3(scale[0], scale[1], scale[2]);
          
          const material = new BABYLON.StandardMaterial(`tankMat-${index}`, scene);
          material.diffuseColor = new BABYLON.Color3(0.75, 0.75, 0.75); // Silver
          material.specularColor = new BABYLON.Color3(0.9, 0.9, 0.9);
          cylinder.material = material;
          
          cylinder.checkCollisions = true;
          cylinder.receiveShadows = true;
          shadowGenerator.addShadowCaster(cylinder);
        });
        */
        await Promise.all(loadPromises);
        
      } catch (error) {
        console.error('Error loading scene:', error);
        document.querySelector('#loading').textContent = 'Error loading scene';
      }
    };
    
    const updateLoadingProgress = (loaded, total) => {
      const loadingEl = document.querySelector('#loading');
      loadingEl.textContent = `Loading assets... ${loaded}/${total}`;
      
      if (loaded >= total) {
        setTimeout(() => {
          loadingEl.style.display = 'none';
        }, 500);
      }
    };
    
    // Initialize scene
    createScene().then(() => {
      engine.runRenderLoop(() => {
        scene.render();
      });
    });
    
 // 1. Create a ResizeObserver to watch the canvas specifically
const resizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
        if (entry.target === canvas) {
            // Force Babylon to recalculate viewport
            engine.resize();
            console.log("Canvas Resized:", canvas.width, "x", canvas.height);
        }
    }
});

// 2. Start observing
resizeObserver.observe(canvas);

// 3. Keep the old listener as a fallback for older browsers
window.addEventListener('resize', () => {
    engine.resize();
});

// 4. Handle Orientation Change (Specific to mobile devices)
window.addEventListener("orientationchange", () => {
    // Small delay to allow the browser to finalize the rotation
    setTimeout(() => { engine.resize(); }, 200);
});
    
    // Click to enable pointer lock
    canvas.addEventListener('click', () => {
      canvas.requestPointerLock = canvas.requestPointerLock || 
                                   canvas.mozRequestPointerLock || 
                                   canvas.webkitRequestPointerLock;
      if (canvas.requestPointerLock) {
        canvas.requestPointerLock();
      }
    });
  </script>
</body>
</html>