<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Drone Wars</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #loading {
      position: fixed; inset: 0; display: flex; align-items: center;
      justify-content: center; background: #111; color: #fff;
      font-size: 22px; z-index: 100; flex-direction: column; gap: 12px;
    }
    #loading.hidden { display: none; }
    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 16px; height: 16px; pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute; background: rgba(255,255,255,0.8);
    }
    #crosshair::before { width: 2px; height: 16px; left: 7px; top: 0; }
    #crosshair::after  { width: 16px; height: 2px; left: 0; top: 7px; }
    #hud {
      position: fixed; bottom: 20px; left: 20px;
      color: #0f0; font-size: 13px; font-family: monospace;
      text-shadow: 0 0 4px #0f0; pointer-events: none;
      line-height: 1.8;
    }
    #info {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.6); font-size: 12px; pointer-events: none;
      text-align: center; line-height: 1.6;
    }
  </style>
</head>
<body>

<div id="loading">
  <div>DRONE WARS</div>
  <div style="font-size:14px; color:#888">Loading assets...</div>
</div>

<div id="crosshair"></div>
<div id="hud">
  <div id="hud-drones">DRONES: 0</div>
  <div id="hud-grounded">GROUNDED: YES</div>
  <div id="hud-pos">POS: 0.0, 0.0, 0.0</div>
  <div id="hud-duck">DUCK: NO</div>
  <div id="hud-ammo">SHOTS FIRED: 0</div>
</div>
<div id="info">
  WASD â€” Move &nbsp;|&nbsp; MOUSE â€” Look &nbsp;|&nbsp; SPACE â€” Jump &nbsp;|&nbsp; C â€” Duck &nbsp;|&nbsp; F â€” FreeCam &nbsp;|&nbsp; 0 â€” Spawn Drone &nbsp;|&nbsp; LEFT CLICK â€” Shoot &nbsp;|&nbsp; CLICK â€” Lock Mouse
</div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- Yuka -->
<script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
<!-- Tone.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<!-- Rapier -->
<script type="module">
  import RAPIER from 'https://scottgrocott.github.io/metal_throne/assets/js/rapier3d-compat/rapier.mjs';
  window.RAPIER = RAPIER;
</script>

<script>
// ============================================================
//  DRONE WARS â€” Three.js + Tone.js + Yuka + Rapier
// ============================================================

// ---- CONSTANTS ----
const SCENE_JSON = '/drone_wars/drone_wars_assets_dev.json';
const GROUND_TEX = 'https://scottgrocott.github.io/metal_throne/assets/img/gpt_ground.png';
const LADDER_TEX = 'https://scottgrocott.github.io/metal_throne/assets/img/ladder.png';

// ---- CONFIGURABLE GAME SETTINGS ----
const CONFIG = {
  // Drone launch building origin â€” the "stargate" that must be destroyed
  launchPoint: { x: -13, y: 2, z: 2.8 },

  // How high (world Y) the drone must rise to before engaging pathfinding
  // (set this to clear the top of the smoke stack)
  droneRiseHeight: 8,

  // Drone flight behaviour
  droneMaxSpeed: 5,
  dronePathRadius: 4.0,   // waypoint arrival radius â€” larger = smoother advance through waypoints
  droneFlightHeight: 2.5, // minimum Y height drones fly at (set to clear your ground floor)

  // Freecam / noclip
  freeFlyCamSpeed: 20,   // units per second in freecam

  // Gun
  gunRange: 200,
  gunPower: 8,             // knock-back impulse on hit
  bulletSpeed: 60,
  bulletRadius: 0.12,
  bulletLife: 3.0,         // seconds before bullet disappears

  // Drone health
  hitsToDetonate: 10,
};

// ---- PLAYER ----
const PLAYER = {
  height: 1.6, radius: 0.4, mass: 80,
  jumpForce: 1000, moveSpeed: 5000, maxVelocity: 5,
  duckHeight: 0.9,
};

const LADDERS = [
  { position: [-5,    0,    0],      height: 5,  width: .5, climbSpeed: 3 },
  { position: [0,   -0.60296, -9.54734], height: 10, width: 1, climbSpeed: 7 },
  { position: [-11.44083, 0, 1.05525],   height: 8,  width: 1, climbSpeed: 7 },
  { position: [-0.83595, 0, 38.20815],   height: 10, width: 1, climbSpeed: 7 },
];

// ---- THREE.JS SETUP ----
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 100, 800);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);

// ---- LIGHTING â€” midday bright sun ----
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xfffde8, 2.2);
sunLight.position.set(80, 200, 60);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width  = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 1;
sunLight.shadow.camera.far  = 800;
sunLight.shadow.camera.left   = -200;
sunLight.shadow.camera.right  =  200;
sunLight.shadow.camera.top    =  200;
sunLight.shadow.camera.bottom = -200;
sunLight.shadow.bias = -0.0003;
sunLight.shadow.normalBias = 0.02;
scene.add(sunLight);

// Soft fill from sky (hemisphere)
const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.5);
scene.add(hemiLight);

const dirLight = sunLight; // keep dirLight reference for any existing code

// ---- RESIZE ----
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ---- POINTER LOCK ----
const pointerLock = {
  locked: false,
  euler: new THREE.Euler(0, 0, 0, 'YXZ'),
  PI_2: Math.PI / 2
};

document.addEventListener('pointerlockchange', () => {
  pointerLock.locked = document.pointerLockElement === renderer.domElement;
});
document.addEventListener('mousemove', (e) => {
  if (!pointerLock.locked) return;
  const sens = 0.002;
  pointerLock.euler.y -= e.movementX * sens;
  pointerLock.euler.x -= e.movementY * sens;
  pointerLock.euler.x = Math.max(-pointerLock.PI_2, Math.min(pointerLock.PI_2, pointerLock.euler.x));
  camera.quaternion.setFromEuler(pointerLock.euler);
});

// ---- TEXTURE LOADER ----
const texLoader = new THREE.TextureLoader();
const gltfLoader = new THREE.GLTFLoader();

// ---- GROUND ----
const groundTex = texLoader.load(GROUND_TEX);
groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
groundTex.repeat.set(2250, 2250);
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10000, 10000),
  new THREE.MeshStandardMaterial({ map: groundTex, roughness: 0.95, metalness: 0.05, color: 0x8B7355 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ============================================================
//  RAPIER PHYSICS
// ============================================================
let physicsWorld = null;
let physicsReady = false;
let physicsAccumulator = 0;
const PHYSICS_DT = 1 / 60;

async function initPhysics() {
  while (!window.RAPIER) await sleep(100);
  await window.RAPIER.init();
  physicsWorld = new window.RAPIER.World({ x: 0, y: -9.81, z: 0 });
  physicsReady = true;
  console.log('âœ… Rapier physics initialized');

  const R = window.RAPIER;
  const groundBody = physicsWorld.createRigidBody(R.RigidBodyDesc.fixed().setTranslation(0, -0.5, 0));
  physicsWorld.createCollider(R.ColliderDesc.cuboid(5000, 0.5, 5000), groundBody);
}

// All raycasting uses Three.js only â€” zero Rapier/WASM involvement.
// Building meshes collected into raycastMeshes[] as they load.
const raycastMeshes = [];
const _threeRaycaster = new THREE.Raycaster();
let _rayQueryResults = {};

const WALL_SENSE_DIST = 5.0;
const WALL_AVOID_DIRS = (() => {
  const dirs = [];
  for (let i = 0; i < 8; i++) {
    const a = (i / 8) * Math.PI * 2;
    dirs.push(new THREE.Vector3(Math.cos(a), 0, Math.sin(a)));
  }
  return dirs;
})();

function queryPhysics() {
  _rayQueryResults = {};

  // Player grounded: simple height check against ground plane (yâ‰ˆ0)
  player.isGrounded = playerRig.position.y <= PLAYER.height + 0.25;

  if (!raycastMeshes.length) return;

  for (const drone of drones) {
    if (drone.dead) continue;
    const pos = drone.group.position;
    const result = { wallPush: { x: 0, z: 0 }, detonatorHit: false };

    // 8 horizontal rays for wall avoidance
    for (const dir of WALL_AVOID_DIRS) {
      _threeRaycaster.set(pos, dir);
      _threeRaycaster.far = WALL_SENSE_DIST;
      const hits = _threeRaycaster.intersectObjects(raycastMeshes, false);
      if (hits.length) {
        const d = hits[0].distance;
        const strength = (1 - d / WALL_SENSE_DIST) * 6;
        result.wallPush.x -= dir.x * strength;
        result.wallPush.z -= dir.z * strength;
      }
    }

    // Detonator geometry probe
    if (drone.detonatorArmed) {
      const detWorld = new THREE.Vector3();
      drone.detonatorMesh.getWorldPosition(detWorld);
      const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(drone.group.quaternion).normalize();
      _threeRaycaster.set(detWorld, fwd);
      _threeRaycaster.far = 0.5;
      const hits = _threeRaycaster.intersectObjects(raycastMeshes, false);
      if (hits.length && hits[0].distance < 0.5) result.detonatorHit = true;
    }

    _rayQueryResults[drone.id] = result;
  }
}

function stepPhysics(dt) {
  if (!physicsReady) return;
  physicsAccumulator += Math.min(dt, 0.1);
  while (physicsAccumulator >= PHYSICS_DT) {
    physicsWorld.step();
    physicsAccumulator -= PHYSICS_DT;
  }
}

// ============================================================
//  PLAYER
// ============================================================
const playerRig = new THREE.Group();
playerRig.position.set(0, PLAYER.height, 0);
playerRig.add(camera);
scene.add(playerRig);

const player = {
  rigidBody: null, collider: null,
  isGrounded: false, justJumped: false,
  onLadder: false, isDucking: false,
  freeCam: false,
  keys: { w:false, s:false, a:false, d:false, space:false, duck:false },
  moveDir: new THREE.Vector3(),
  shotsFired: 0,
};

function initPlayer() {
  const R = window.RAPIER;
  const pos = playerRig.position;
  player.rigidBody = physicsWorld.createRigidBody(
    R.RigidBodyDesc.dynamic()
      .setTranslation(pos.x, pos.y, pos.z)
      .lockRotations()
      .setLinearDamping(5.0)
  );
  player.collider = physicsWorld.createCollider(
    R.ColliderDesc.capsule(PLAYER.height/2 - PLAYER.radius, PLAYER.radius)
      .setMass(PLAYER.mass).setFriction(0).setRestitution(0),
    player.rigidBody
  );
  console.log('âœ… Player physics body created');
}

// Keys
window.addEventListener('keydown', e => {
  if (e.code==='KeyW'||e.code==='ArrowUp')    player.keys.w = true;
  if (e.code==='KeyS'||e.code==='ArrowDown')  player.keys.s = true;
  if (e.code==='KeyA'||e.code==='ArrowLeft')  player.keys.a = true;
  if (e.code==='KeyD'||e.code==='ArrowRight') player.keys.d = true;
  if (e.code==='Space') { player.keys.space = true; e.preventDefault(); }
  if (e.code==='KeyF') {
    player.freeCam = !player.freeCam;
    if (player.freeCam) {
      // Freeze physics body so it doesn't fall while flying
      if (player.rigidBody) player.rigidBody.setEnabled(false);
    } else {
      // Re-enable physics and teleport body to current camera position
      if (player.rigidBody) {
        player.rigidBody.setEnabled(true);
        player.rigidBody.setTranslation({ x: playerRig.position.x, y: playerRig.position.y, z: playerRig.position.z }, true);
        player.rigidBody.setLinvel({ x:0, y:0, z:0 }, true);
      }
    }
    console.log('ðŸŽ¥ FreeCam:', player.freeCam ? 'ON' : 'OFF');
  }
  if (e.code==='KeyC') player.keys.duck = true;
  if (e.code==='Digit0' || e.code==='Numpad0') spawnDrone();
});
window.addEventListener('keyup', e => {
  if (e.code==='KeyW'||e.code==='ArrowUp')    player.keys.w = false;
  if (e.code==='KeyS'||e.code==='ArrowDown')  player.keys.s = false;
  if (e.code==='KeyA'||e.code==='ArrowLeft')  player.keys.a = false;
  if (e.code==='KeyD'||e.code==='ArrowRight') player.keys.d = false;
  if (e.code==='Space') { player.keys.space = false; player.justJumped = false; }
  if (e.code==='KeyC') player.keys.duck = false;
});

// Left-click shoot (only when locked)
document.addEventListener('mousedown', async (e) => {
  if (e.button === 0 && !pointerLock.locked) {
    await Tone.start();
    renderer.domElement.requestPointerLock();
    return;
  }
  if (e.button === 0 && pointerLock.locked) {
    shootBullet();
  }
});

function tickPlayer(dt) {
  if (!player.rigidBody) return;

  // ---- FREECAM MODE ----
  if (player.freeCam) {
    const speed = CONFIG.freeFlyCamSpeed;
    const yaw   = pointerLock.euler.y;
    const pitch = pointerLock.euler.x;
    const fwd   = new THREE.Vector3(-Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw)*Math.cos(pitch));
    const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
    const move  = new THREE.Vector3();

    if (player.keys.w) move.addScaledVector(fwd, 1);
    if (player.keys.s) move.addScaledVector(fwd, -1);
    if (player.keys.a) move.addScaledVector(right, -1);
    if (player.keys.d) move.addScaledVector(right, 1);
    if (player.keys.space) move.y += 1;     // float up
    if (player.keys.duck)  move.y -= 1;     // float down

    if (move.length() > 0) move.normalize();
    playerRig.position.addScaledVector(move, speed * dt);

    const p = playerRig.position;
    document.getElementById('hud-grounded').textContent = 'GROUNDED: FREECAM';
    document.getElementById('hud-duck').textContent     = 'DUCK: â€”';
    document.getElementById('hud-pos').textContent      = `POS: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
    document.getElementById('hud-ammo').textContent     = 'SHOTS FIRED: ' + player.shotsFired;
    return;
  }

  // Duck â€” camera lowers when ducking (was inverted: tippy-toes instead of crouch)
  const wantDuck = player.keys.duck;
  if (wantDuck !== player.isDucking) {
    player.isDucking = wantDuck;
    // Standing: camera at 0 (relative to playerRig which is already at PLAYER.height)
    // Ducking: camera drops by (PLAYER.height - PLAYER.duckHeight)
    camera.position.y = player.isDucking ? -(PLAYER.height - PLAYER.duckHeight) : 0;
  }

  const yaw = pointerLock.euler.y;
  player.moveDir.set(0, 0, 0);
  if (player.keys.w) { player.moveDir.x -= Math.sin(yaw); player.moveDir.z -= Math.cos(yaw); }
  if (player.keys.s) { player.moveDir.x += Math.sin(yaw); player.moveDir.z += Math.cos(yaw); }
  if (player.keys.a) { player.moveDir.x -= Math.cos(yaw); player.moveDir.z += Math.sin(yaw); }
  if (player.keys.d) { player.moveDir.x += Math.cos(yaw); player.moveDir.z -= Math.sin(yaw); }
  if (player.moveDir.length() > 0) player.moveDir.normalize();

  const spd = player.isDucking ? PLAYER.maxVelocity * 0.5 : PLAYER.maxVelocity;
  const vel = _physCache.playerVel; // cached â€” no Rapier borrow
  const hspeed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
  if (hspeed < spd) {
    player.rigidBody.applyImpulse({
      x: player.moveDir.x * PLAYER.moveSpeed * dt,
      y: 0,
      z: player.moveDir.z * PLAYER.moveSpeed * dt
    }, true);
  }

  if (player.keys.space && player.isGrounded && !player.justJumped && !player.onLadder && !player.isDucking) {
    player.rigidBody.applyImpulse({ x:0, y:PLAYER.jumpForce, z:0 }, true);
    player.justJumped = true;
  }

  // Sync Three.js from cache
  const p = _physCache.playerPos;
  playerRig.position.set(p.x, p.y, p.z);

  document.getElementById('hud-grounded').textContent = 'GROUNDED: ' + (player.isGrounded ? 'YES' : 'NO');
  document.getElementById('hud-duck').textContent = 'DUCK: ' + (player.isDucking ? 'YES' : 'NO');
  document.getElementById('hud-pos').textContent = `POS: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
  document.getElementById('hud-ammo').textContent = 'SHOTS FIRED: ' + player.shotsFired;
}

function checkGrounded() {} // no-op â€” computed in queryPhysics()

// ---- Physics read cache â€” populated once after stepPhysics, used everywhere else ----
// Rule: NEVER call .translation()/.linvel()/.rotation() outside of syncPhysicsReads()
const _physCache = {
  playerPos: { x:0, y:0, z:0 },
  playerVel: { x:0, y:0, z:0 },
  deadDrones: {}, // id -> { pos, rot }
};

function syncPhysicsReads() {
  if (!physicsReady) return;
  try {
    if (player.rigidBody) {
      const p = player.rigidBody.translation();
      const v = player.rigidBody.linvel();
      _physCache.playerPos.x = p.x; _physCache.playerPos.y = p.y; _physCache.playerPos.z = p.z;
      _physCache.playerVel.x = v.x; _physCache.playerVel.y = v.y; _physCache.playerVel.z = v.z;
    }
  } catch(e) {}
  _physCache.deadDrones = {};
  drones.forEach(drone => {
    if (drone.dead && drone.body) {
      try {
        const p = drone.body.translation();
        const r = drone.body.rotation();
        _physCache.deadDrones[drone.id] = {
          pos: { x:p.x, y:p.y, z:p.z },
          rot: { x:r.x, y:r.y, z:r.z, w:r.w }
        };
      } catch(e) {}
    }
  });
}

// ============================================================
//  BUILDINGS
// ============================================================
const buildingBodies = [];

function loadBuildings(data) {
  // Pre-load ground texture for terrain reuse
  const terrainGroundTex = texLoader.load(GROUND_TEX);
  terrainGroundTex.wrapS = terrainGroundTex.wrapT = THREE.RepeatWrapping;
  terrainGroundTex.repeat.set(2250, 2250); // same tiling as the flat ground plane

  data.buildings.forEach(b => {
    const [px, py, pz] = b.position.split(' ').map(Number);
    const [sx, sy, sz] = (b.scale||'1 1 1').split(' ').map(n => Number(n) * (b.class === 'terrain' ? 1 : 1.15));

    const isTerrain = b.class === 'terrain';

    gltfLoader.load(
      b.model.startsWith('#') ? getAssetSrc(data.assets, b.model.slice(1)) : b.model,
      (gltf) => {
        const model = gltf.scene;
        model.position.set(px, py, pz);
        model.scale.set(sx, sy, sz);
        model.traverse(n => {
          if (n.isMesh) {
            n.castShadow  = !isTerrain; // terrain receives but doesn't self-cast (perf)
            n.receiveShadow = true;
            if (isTerrain) {
              // Force the ground texture onto all terrain meshes at the same tiling level
              const mat = new THREE.MeshStandardMaterial({
                map: terrainGroundTex,
                roughness: 0.95,
                metalness: 0.05,
                color: 0x8B7355,
              });
              n.material = mat;
            }
            raycastMeshes.push(n);
          }
        });
        scene.add(model);
        if (!isTerrain) {
          buildStaticCollider(model);
        } else {
          // Terrain gets its own collider â€” same trimesh path
          // (If the model is too heavy at 3MB, comment out the next line until decimated)
          buildStaticCollider(model);
        }
        console.log('âœ… ' + (isTerrain ? 'Terrain' : 'Building') + ' loaded:', b.id);
      },
      null,
      (e) => console.error('âŒ Load error:', b.id, e)
    );
  });
}

function getAssetSrc(assets, id) {
  const a = assets.find(a => a.id === id);
  return a ? a.src : null;
}

function buildStaticCollider(model) {
  const R = window.RAPIER;
  const vertices = [];
  const indices  = [];
  let idx = 0;

  model.updateWorldMatrix(true, true);
  model.traverse(node => {
    if (!node.isMesh) return;
    const geo = node.geometry;
    const pos = geo.attributes.position;
    const tmp = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      tmp.fromBufferAttribute(pos, i).applyMatrix4(node.matrixWorld);
      vertices.push(tmp.x, tmp.y, tmp.z);
    }
    const baseIdx = idx;
    if (geo.index) {
      for (let i = 0; i < geo.index.count; i++) indices.push(baseIdx + geo.index.getX(i));
      idx += pos.count;
    } else {
      for (let i = 0; i < pos.count; i++) indices.push(baseIdx + i);
      idx += pos.count;
    }
  });

  const body = physicsWorld.createRigidBody(R.RigidBodyDesc.fixed());
  physicsWorld.createCollider(
    R.ColliderDesc.trimesh(new Float32Array(vertices), new Uint32Array(indices)),
    body
  );
  buildingBodies.push(body);
  console.log('âœ… Static collider created, triangles:', indices.length / 3);
}

// ============================================================
//  LADDERS
// ============================================================
const ladderTexture = texLoader.load(LADDER_TEX);
const ladderInstances = [];

function initLadders() {
  LADDERS.forEach(def => {
    const [lx, ly, lz] = def.position;
    const mat = new THREE.MeshStandardMaterial({ map: ladderTexture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(def.width, def.height, 0.05), mat);
    mesh.position.set(lx, ly + def.height / 2, lz);
    scene.add(mesh);
    ladderInstances.push({
      position: new THREE.Vector3(lx, ly, lz),
      height: def.height, width: def.width,
      climbSpeed: def.climbSpeed,
      active: false
    });
  });
  console.log('âœ… Ladders initialized:', ladderInstances.length);
}

function tickLadders() {
  if (!player.rigidBody) return;
  const pp = _physCache.playerPos; // cached â€” no Rapier borrow
  const pv = new THREE.Vector3(pp.x, pp.y, pp.z);
  player.onLadder = false;
  ladderInstances.forEach(l => {
    const dx = Math.abs(pv.x - l.position.x);
    const dy = Math.abs(pv.y - (l.position.y + l.height/2));
    const dz = Math.abs(pv.z - l.position.z);
    const on = dx < (l.width/2 + 0.5) && dy < (l.height/2 + 0.5) && dz < 1.0;
    if (on) {
      player.onLadder = true;
      const up = player.keys.w || player.keys.space;
      const dn = player.keys.s;
      if (up || dn) {
        const dir = up ? 1 : -1;
        const vel = _physCache.playerVel; // cached
        player.rigidBody.setLinvel({ x: vel.x*0.5, y: dir*l.climbSpeed, z: vel.z*0.5 }, true);
      }
    }
  });
}

// ============================================================
//  TONE.JS AUDIO
// ============================================================
let toneReady = false;
let windNoise = null;
let windGain = null;

// Pentatonic pitches (Hz) for drone identification â€” each drone gets its own pitch
const DRONE_PITCHES = [110, 130.81, 164.81, 196, 246.94, 293.66, 329.63, 392];

function initAudio() {
  // ---- Environment: wind ----
  try {
    const noiseNode = new Tone.Noise('pink').start();
    const autoFilter = new Tone.AutoFilter({ frequency: '0.1', baseFrequency: 200, octaves: 3 }).start();
    const windEnv = new Tone.Volume(-28);
    noiseNode.connect(autoFilter);
    autoFilter.connect(windEnv);
    windEnv.toDestination();

    // Occasional wind gusts
    function windGust() {
      const t = Tone.now();
      windEnv.volume.rampTo(-20, 2, t);
      windEnv.volume.rampTo(-40, 3, t + 2 + Math.random()*3);
      setTimeout(windGust, 6000 + Math.random() * 12000);
    }
    windGust();

    toneReady = true;
    console.log('âœ… Tone.js audio initialized');
  } catch(e) {
    console.warn('Audio init error:', e);
  }
}

// Create a spatial-ish drone buzz synth
// Uses a sawtooth + distortion + lowpass, panned by position relative to listener
function createDroneSynth(pitchHz, droneIndex) {
  const freq = DRONE_PITCHES[droneIndex % DRONE_PITCHES.length];

  // Layered oscillators for rich buzzing
  const osc1 = new Tone.Oscillator(freq, 'sawtooth');
  const osc2 = new Tone.Oscillator(freq * 1.01, 'square'); // slight detune
  const osc3 = new Tone.Oscillator(freq * 2, 'sawtooth');  // harmonic

  const distortion = new Tone.Distortion(0.4);
  const filter = new Tone.Filter(800, 'lowpass');
  const panner = new Tone.Panner(0);
  const vol = new Tone.Volume(-18);

  osc1.connect(distortion);
  osc2.connect(distortion);
  osc3.connect(distortion);
  distortion.connect(filter);
  filter.connect(panner);
  panner.connect(vol);
  vol.toDestination();

  osc1.start(); osc2.start(); osc3.start();

  return { osc1, osc2, osc3, panner, vol, filter, baseFreq: freq };
}

// Update spatial panning & volume for a drone synth based on 3D position
function updateDroneSpatial(synth, dronePos) {
  if (!synth) return;
  try {
    // Use playerRig (Three.js, no Rapier borrow) instead of rigidBody.translation()
    const pp = playerRig.position;
    const dx = dronePos.x - pp.x;
    const dy = dronePos.y - pp.y;
    const dz = dronePos.z - pp.z;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (!isFinite(dist) || dist < 0.01) return; // too close or invalid, skip

    // Volume falloff â€” smooth inverse-square-ish curve over a long range
    const maxDist = 120;  // audible out to 120 units (was 50)
    const minVol  = -60;
    const maxVol  = -4;
    // Smooth rolloff: starts at maxVol when very close, falls off gradually
    const normDist = Math.min(dist / maxDist, 1.0);
    const vol = dist < maxDist
      ? maxVol + (minVol - maxVol) * (normDist * normDist)  // quadratic â€” gentle at close range, steeper further out
      : minVol;
    // Use a long time constant (0.8s) so volume changes feel gradual, not snappy
    if (isFinite(vol)) synth.vol.volume.setTargetAtTime(vol, Tone.now(), 0.8);

    // Pan â€” guard zero horizontal length
    const hLen = Math.sqrt(dx*dx + dz*dz);
    if (hLen > 0.01) {
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
      const toDrone = new THREE.Vector3(dx / hLen, 0, dz / hLen);
      const pan = Math.max(-1, Math.min(1, toDrone.dot(right)));
      if (isFinite(pan)) synth.panner.pan.setTargetAtTime(pan, Tone.now(), 0.05);
    }

    // Pitch â€” clamp to safe range
    const speed = Math.max(0.5, Math.min(2.0, 1 - dist / 80));
    const f1 = synth.baseFreq * speed;
    const f2 = synth.baseFreq * 1.01 * speed;
    const f3 = synth.baseFreq * 2 * speed;
    if (isFinite(f1) && f1 > 0) {
      synth.osc1.frequency.setTargetAtTime(f1, Tone.now(), 0.2);
      synth.osc2.frequency.setTargetAtTime(f2, Tone.now(), 0.2);
      synth.osc3.frequency.setTargetAtTime(f3, Tone.now(), 0.2);
    }
  } catch(e) {}
}

// Explosion sound synth
function playExplosion(pos) {
  if (!toneReady) return;
  try {
    const noise = new Tone.Noise('white');
    const env   = new Tone.AmplitudeEnvelope({ attack: 0.01, decay: 0.4, sustain: 0, release: 0.5 });
    const dist  = new Tone.Distortion(0.8);
    const filt  = new Tone.Filter(400, 'lowpass');
    const vol   = new Tone.Volume(-6);
    noise.connect(env); env.connect(dist); dist.connect(filt); filt.connect(vol); vol.toDestination();
    noise.start();
    env.triggerAttackRelease('1');
    setTimeout(() => { try { noise.stop(); noise.dispose(); env.dispose(); dist.dispose(); filt.dispose(); vol.dispose(); } catch(e){} }, 2000);
  } catch(e) {}
}

// Gun shot synth
function playGunshot() {
  if (!toneReady) return;
  try {
    const noise = new Tone.Noise('white');
    const env   = new Tone.AmplitudeEnvelope({ attack: 0.001, decay: 0.08, sustain: 0, release: 0.1 });
    const filt  = new Tone.Filter(2000, 'highpass');
    const vol   = new Tone.Volume(-10);
    noise.connect(env); env.connect(filt); filt.connect(vol); vol.toDestination();
    noise.start();
    env.triggerAttackRelease('0.1');
    setTimeout(() => { try { noise.stop(); noise.dispose(); env.dispose(); filt.dispose(); vol.dispose(); } catch(e){} }, 500);
  } catch(e) {}
}

// Bullet hit synth (thud / ding)
function playBulletHit() {
  if (!toneReady) return;
  try {
    const synth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 } });
    synth.toDestination();
    synth.triggerAttackRelease(440, '0.1');
    setTimeout(() => { try { synth.dispose(); } catch(e){} }, 500);
  } catch(e) {}
}

// ============================================================
//  YUKA AI
// ============================================================
const yukaManager = new YUKA.EntityManager();
const yukaTime    = new YUKA.Time();
const flightWaypoints = [];

// ============================================================
//  DRONES
// ============================================================
const drones = [];
let droneCount = 0;

function randomRGB() {
  return new THREE.Color(Math.random(), Math.random() * 0.5 + 0.3, Math.random() * 0.3);
}

function spawnDrone() {
  if (!physicsReady) return;
  const R = window.RAPIER;

  const lp = CONFIG.launchPoint;
  // Spawn exactly at the launch point with no random scatter â€” rises straight up
  const ox = lp.x;
  const oz = lp.z;
  const oy = lp.y;

  const spawnPos = new THREE.Vector3(ox, oy, oz);
  const color = randomRGB();
  const myIndex = droneCount;

  // ---- Visual: body ----
  const group = new THREE.Group();
  group.position.copy(spawnPos);

  const bodyMat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6, metalness: 0.3, roughness: 0.5 });
  group.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.25, 1.5), bodyMat));

  // Rotors
  const rotorMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xff2200, emissiveIntensity: 1 });
  const rotorGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 8);
  [[-0.8,0.15,-0.8],[0.8,0.15,-0.8],[-0.8,0.15,0.8],[0.8,0.15,0.8]].forEach(([x,y,z]) => {
    const r = new THREE.Mesh(rotorGeo, rotorMat);
    r.position.set(x, y, z);
    group.add(r);
  });

  // ---- DETONATOR: cylinder on the front ----
  const detMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff0000, emissiveIntensity: 1.5, metalness: 0.8, roughness: 0.2 });
  const detMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.5, 8), detMat);
  detMesh.rotation.x = Math.PI / 2;
  detMesh.position.set(0, 0, 0.9);
  group.add(detMesh);

  scene.add(group);

  // [REMOVED] spawn marker sphere â€” was debug only

  // ---- Physics (kinematic) ----
  const body = physicsWorld.createRigidBody(
    R.RigidBodyDesc.kinematicPositionBased().setTranslation(ox, oy, oz)
  );
  const collider = physicsWorld.createCollider(
    R.ColliderDesc.ball(0.6).setMass(2).setFriction(0).setRestitution(0.3),
    body
  );

  // ---- Simple manual waypoint follower (no Yuka steering) ----
  let wpIndex = Math.floor(Math.random() * Math.max(1, flightWaypoints.length));
  const vel = new THREE.Vector3(1, 0, 0);
  const pos = new THREE.Vector3(ox, oy, oz);

  // Dummy Yuka vehicle for manager compatibility
  const vehicle = new YUKA.Vehicle();
  vehicle.maxSpeed = CONFIG.droneMaxSpeed;
  vehicle.position.set(ox, oy, oz);
  yukaManager.add(vehicle);

  // Each drone gets a unique height offset so they fly at different levels
  const heightOffset = (droneCount % 5) * 1.2 - 2.4;

  // Drone AI state machine
  // 'rising'  â€” ascending from stargate to clear smoke stack
  // 'patrol'  â€” following waypoints
  // 'hunting' â€” locked onto player, closing in to ram
  let droneState = 'rising';
  let huntCooldown = 0; // seconds remaining on hunt mode after losing LOS

  // Detection raycaster â€” reused per drone
  const detectRay = new THREE.Raycaster();

  function canSeePlayer() {
    const dp = pos;
    const pp = playerRig.position;
    const toPlayer = new THREE.Vector3(pp.x - dp.x, pp.y - dp.y, pp.z - dp.z);
    const dist = toPlayer.length();
    if (dist > 60) return false; // beyond detection range
    toPlayer.normalize();
    detectRay.set(new THREE.Vector3(dp.x, dp.y, dp.z), toPlayer);
    detectRay.far = dist;
    const hits = detectRay.intersectObjects(raycastMeshes, false);
    // No geometry blocking the line of sight
    return hits.length === 0;
  }

  function updateMovement(dt, wallPush) {
    if (!flightWaypoints.length) return;

    // ---- RISE PHASE ----
    if (droneState === 'rising') {
      const targetY = CONFIG.droneRiseHeight;
      const dy = targetY - pos.y;
      const riseSpeed = CONFIG.droneMaxSpeed * 0.6;
      vel.set(0, dy > 0 ? riseSpeed : 0, 0);
      pos.y += vel.y * dt;
      if (pos.y >= targetY) {
        pos.y = targetY;
        droneState = 'patrol';
      }
      group.position.copy(pos);
      try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}
      return;
    }

    // ---- DETECT PLAYER â€” upgrade to hunt ----
    if (droneState === 'patrol') {
      if (canSeePlayer()) {
        droneState = 'hunting';
        huntCooldown = 4.0; // chase for at least 4 seconds after losing sight
      }
    }

    // ---- HUNT MODE ----
    if (droneState === 'hunting') {
      huntCooldown -= dt;
      const pp = playerRig.position;
      const dx = pp.x - pos.x;
      const dy = pp.y - pos.y;
      const dz = pp.z - pos.z;
      const fullDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      const invDist = fullDist > 0.01 ? 1 / fullDist : 0;
      const speed = CONFIG.droneMaxSpeed * 1.6; // faster when hunting

      const desiredX = dx * invDist * speed;
      const desiredY = dy * invDist * speed;
      const desiredZ = dz * invDist * speed;

      const turn = Math.min(1, dt * 5);
      vel.x += (desiredX - vel.x) * turn;
      vel.y += (desiredY - vel.y) * turn;
      vel.z += (desiredZ - vel.z) * turn;

      if (wallPush) { vel.x += wallPush.x * 0.12; vel.z += wallPush.z * 0.12; }

      const spd = vel.length();
      if (spd > speed) vel.multiplyScalar(speed / spd);

      pos.x += vel.x * dt;
      pos.y += vel.y * dt;
      pos.z += vel.z * dt;
      group.position.copy(pos);
      if (spd > 0.1) group.rotation.y = Math.atan2(vel.x, vel.z);
      try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}

      // Revert to patrol if hunt timer runs out and no sight
      if (huntCooldown <= 0 && !canSeePlayer()) {
        droneState = 'patrol';
      }
      return;
    }

    // ---- PATROL MODE ----
    const target = flightWaypoints[wpIndex % flightWaypoints.length];
    const ty = CONFIG.droneFlightHeight + heightOffset;
    const dx = target.x - pos.x;
    const dy = ty - pos.y;
    const dz = target.z - pos.z;
    const dist = Math.sqrt(dx*dx + dz*dz);

    if (dist < CONFIG.dronePathRadius) {
      wpIndex = (wpIndex + 1) % flightWaypoints.length;
    }

    const speed = CONFIG.droneMaxSpeed;
    const fullDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const invDist = fullDist > 0.01 ? 1 / fullDist : 0;

    const desiredX = dx * invDist * speed;
    const desiredY = dy * invDist * speed;
    const desiredZ = dz * invDist * speed;

    const turn = Math.min(1, dt * 4);
    vel.x += (desiredX - vel.x) * turn;
    vel.y += (desiredY - vel.y) * turn;
    vel.z += (desiredZ - vel.z) * turn;

    if (wallPush) { vel.x += wallPush.x * 0.15; vel.z += wallPush.z * 0.15; }

    const spd = vel.length();
    if (spd > speed) vel.multiplyScalar(speed / spd);

    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;

    group.position.copy(pos);
    if (spd > 0.1) group.rotation.y = Math.atan2(vel.x, vel.z);
    try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}
  }

  // ---- Tone.js buzz synth ----
  let synth = null;
  try {
    if (toneReady) synth = createDroneSynth(DRONE_PITCHES[myIndex % DRONE_PITCHES.length], myIndex);
  } catch(e) { console.warn('Synth create error:', e); }

  const drone = {
    group, body, collider, vehicle,
    synth, dead: false, id: ++droneCount,
    hitCount: 0,
    updateMovement,
    detonatorMesh: detMesh,
    color,
    detonatorArmed: false,
    // Expose state so external code (e.g. bullet hits) can trigger hunt mode
    getState: () => droneState,
    triggerHunt: () => { droneState = 'hunting'; huntCooldown = 6.0; },
  };
  // Arm after 2.5s â€” enough time to rise clear of launch geometry
  setTimeout(() => { if (!drone.dead) drone.detonatorArmed = true; }, 2500);

  drones.push(drone);
  document.getElementById('hud-drones').textContent = 'DRONES: ' + drones.filter(d=>!d.dead).length;
  console.log('ðŸ›¸ Drone spawned #' + drone.id, 'at', ox.toFixed(2), oy.toFixed(2), oz.toFixed(2));
}

function killDrone(drone, fromDetonator = false) {
  if (drone.dead) return;
  drone.dead = true;

  const R = window.RAPIER;
  const pos = drone.group.position;

  playExplosion(pos);

  drone.group.traverse(n => {
    if (n.isMesh && n.material) {
      n.material = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 3 });
    }
  });

  yukaManager.remove(drone.vehicle);

  const oldC = drone.collider;
  const oldB = drone.body;

  drone.body = physicsWorld.createRigidBody(
    R.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z)
  );
  drone.collider = physicsWorld.createCollider(
    R.ColliderDesc.cuboid(0.5, 0.5, 0.5).setMass(2).setRestitution(0.3).setFriction(0.5),
    drone.body
  );
  drone.body.setLinvel({ x:(Math.random()-0.5)*8, y:5, z:(Math.random()-0.5)*8 }, true);
  drone.body.setAngvel({ x:(Math.random()-0.5)*10, y:(Math.random()-0.5)*10, z:(Math.random()-0.5)*10 }, true);

  setTimeout(() => {
    try { physicsWorld.removeCollider(oldC, true); } catch(e){}
    try { physicsWorld.removeRigidBody(oldB); } catch(e){}
  }, 50);

  if (drone.synth) {
    try {
      drone.synth.osc1.stop(); drone.synth.osc2.stop(); drone.synth.osc3.stop();
      setTimeout(() => {
        try { drone.synth.osc1.dispose(); drone.synth.osc2.dispose(); drone.synth.osc3.dispose();
              drone.synth.panner.dispose(); drone.synth.vol.dispose(); drone.synth.filter.dispose(); } catch(e){}
      }, 200);
    } catch(e) {}
    drone.synth = null;
  }

  setTimeout(() => {
    scene.remove(drone.group);
    try { physicsWorld.removeCollider(drone.collider, true); } catch(e){}
    try { physicsWorld.removeRigidBody(drone.body); } catch(e){}
    const idx = drones.indexOf(drone);
    if (idx >= 0) drones.splice(idx, 1);
    document.getElementById('hud-drones').textContent = 'DRONES: ' + drones.filter(d=>!d.dead).length;
  }, 5000);

  console.log('ðŸ’¥ Drone killed #' + drone.id);
}


function tickDrones(dt) {
  drones.forEach(drone => {
    if (drone.dead && drone.body) {
      const cached = _physCache.deadDrones[drone.id];
      if (cached) {
        drone.group.position.set(cached.pos.x, cached.pos.y, cached.pos.z);
        drone.group.quaternion.set(cached.rot.x, cached.rot.y, cached.rot.z, cached.rot.w);
      }
      return;
    }

    if (!drone.dead) {
      // Move drone â€” pass wall avoidance results from pre-queried raycasts
      const qr = _rayQueryResults[drone.id];
      drone.updateMovement(dt, qr ? qr.wallPush : null);

      if (drone.synth) updateDroneSpatial(drone.synth, drone.group.position);

      // Spin rotors
      drone.group.children.forEach((child, i) => {
        if (i >= 1 && i <= 4) child.rotation.y += dt * 20 * (1 + drone.id * 0.3);
      });

      // Detonator checks (only when armed)
      if (drone.detonatorArmed) checkDetonatorCollision(drone);
    }
  });
}

// Detonator collision â€” proximity for player/drones, cached raycast for geometry
function checkDetonatorCollision(drone) {
  if (!player.rigidBody) return;

  const detWorld = new THREE.Vector3();
  drone.detonatorMesh.getWorldPosition(detWorld);

  // --- vs player (use playerRig â€” no Rapier borrow) ---
  const pp = playerRig.position;
  if ((detWorld.x-pp.x)**2+(detWorld.y-pp.y)**2+(detWorld.z-pp.z)**2 < 0.64) {
    console.log('ðŸ’€ Player hit by detonator!');
    killDrone(drone, true);
    return;
  }

  // --- vs other drones (no Rapier needed) ---
  for (const other of drones) {
    if (other === drone || other.dead) continue;
    const op = other.group.position;
    if ((detWorld.x-op.x)**2+(detWorld.y-op.y)**2+(detWorld.z-op.z)**2 < 1.44) {
      killDrone(drone, true);
      killDrone(other, true);
      return;
    }
  }

  // --- vs geometry (use pre-queried results, no live castRay here) ---
  const result = _rayQueryResults[drone.id];
  if (result && result.detonatorHit) {
    console.log('ðŸ’¥ Detonator hit geometry!');
    killDrone(drone, true);
  }
}

// ============================================================
//  BULLETS / GUN
// ============================================================
const bullets = [];

function shootBullet() {
  if (!physicsReady) return;
  if (!toneReady) { Tone.start().catch(()=>{}); }

  playGunshot();
  player.shotsFired++;

  const R = window.RAPIER;

  // Bullet starts at camera world position
  const origin = new THREE.Vector3();
  camera.getWorldPosition(origin);

  // Direction = where camera is looking
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();

  // Visual sphere
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(CONFIG.bulletRadius, 6, 6),
    new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 2 })
  );
  mesh.position.copy(origin);
  scene.add(mesh);

  // Physics â€” kinematic bullet (we move it manually for simplicity)
  const bullet = {
    mesh,
    dir: dir.clone(),
    speed: CONFIG.bulletSpeed,
    life: CONFIG.bulletLife,
    dead: false,
  };
  bullets.push(bullet);
}

function tickBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    if (b.dead) { bullets.splice(i, 1); continue; }

    b.life -= dt;
    if (b.life <= 0) {
      scene.remove(b.mesh);
      b.dead = true;
      bullets.splice(i, 1);
      continue;
    }

    // Move bullet
    const move = b.dir.clone().multiplyScalar(b.speed * dt);
    b.mesh.position.add(move);

    // Check collision with drones
    let hitSomething = false;
    drones.forEach(drone => {
      if (drone.dead || hitSomething) return;
      const dp = drone.group.position;
      const bp = b.mesh.position;
      const dist = bp.distanceTo(dp);

      if (dist < 1.0) {
        // Check if detonator was hit (closer to front)
        const detWorld = new THREE.Vector3();
        drone.detonatorMesh.getWorldPosition(detWorld);
        const detDist = bp.distanceTo(detWorld);

        if (detDist < 0.35) {
          // Direct detonator hit â€” instant kill
          killDrone(drone);
        } else {
          // Body hit â€” bump + increment hit counter + ALERT the drone to hunt player
          drone.hitCount++;
          playBulletHit();
          drone.triggerHunt(); // drone spins and hunts the player

          // Bump the drone visually/physically â€” offset its vehicle position
          const knockDir = new THREE.Vector3(b.dir.x, 0.5, b.dir.z).normalize();
          const ent = drone.vehicle;
          ent.position.x += knockDir.x * 0.5;
          ent.position.y += knockDir.y * 0.3;
          ent.position.z += knockDir.z * 0.5;

          // Flash
          drone.group.children.forEach(child => {
            if (child.isMesh) {
              const origMat = child.material;
              child.material = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 3 });
              setTimeout(() => { child.material = origMat; }, 80);
            }
          });

          if (drone.hitCount >= CONFIG.hitsToDetonate) {
            killDrone(drone);
          }
        }

        hitSomething = true;
      }
    });

    if (hitSomething) {
      scene.remove(b.mesh);
      b.dead = true;
      bullets.splice(i, 1);
    }
  }
}

// ============================================================
//  SCENE JSON LOADER
// ============================================================
async function loadScene() {
  const res  = await fetch(SCENE_JSON);
  const data = await res.json();
  console.log('ðŸ“¦ Scene loaded. Buildings:', data.buildings.length, '| Waypoints:', data.waypoints.length);

  data.waypoints.forEach(wp => {
    const [x,y,z] = wp.position.split(' ').map(Number);
    flightWaypoints.push(new YUKA.Vector3(x, y, z));
  });

  // Add tight orbit waypoints around each building so drones navigate close to geometry.
  // These sit just outside the building bounds at varying heights.
  const h = CONFIG.droneFlightHeight;
  data.buildings.forEach(b => {
    const [bx, by, bz] = b.position.split(' ').map(Number);
    const r = 6; // orbit radius â€” how close to hug the building
    // 4 points around each building at slightly different heights
    [
      [bx + r, h + 1,  bz    ],
      [bx,     h - 1,  bz + r],
      [bx - r, h + 2,  bz    ],
      [bx,     h,      bz - r],
    ].forEach(([wx, wy, wz]) => {
      flightWaypoints.push(new YUKA.Vector3(wx, wy, wz));
    });
  });

  loadBuildings(data);
}

// ============================================================
//  MAIN LOOP
// ============================================================
let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  stepPhysics(dt);
  syncPhysicsReads();    // cache all Rapier reads â€” AFTER step
  queryPhysics();        // Three.js raycasts â€” no Rapier, safe anywhere

  const yukaD = yukaTime.update().getDelta();
  yukaManager.update(yukaD);

  tickPlayer(dt);
  tickLadders();
  tickDrones(dt);
  tickBullets(dt);

  renderer.render(scene, camera);
}

// ============================================================
//  BOOT
// ============================================================
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function boot() {
  await initPhysics();
  initLadders();
  await loadScene();

  await sleep(500);
  initPlayer();

  document.getElementById('loading').classList.add('hidden');

  // Init audio on first user interaction
  const startAudio = async () => {
    await Tone.start();
    initAudio();
    document.removeEventListener('click', startAudio);
    document.removeEventListener('keydown', startAudio);
  };
  document.addEventListener('click', startAudio);
  document.addEventListener('keydown', startAudio);

  animate();
}

boot();
</script>
</body>
</html>