<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Drone Wars</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #loading {
      position: fixed; inset: 0; display: flex; align-items: center;
      justify-content: center; background: #111; color: #fff;
      font-size: 22px; z-index: 100; flex-direction: column; gap: 12px;
    }
    #loading.hidden { display: none; }
    #crosshair {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      width: 16px; height: 16px; pointer-events: none;
    }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute; background: rgba(255,255,255,0.8);
    }
    #crosshair::before { width: 2px; height: 16px; left: 7px; top: 0; }
    #crosshair::after  { width: 16px; height: 2px; left: 0; top: 7px; }
    #hud {
      position: fixed; bottom: 20px; left: 20px;
      color: #0f0; font-size: 13px; font-family: monospace;
      text-shadow: 0 0 4px #0f0; pointer-events: none;
      line-height: 1.8;
    }
    #info {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      color: rgba(255,255,255,0.6); font-size: 12px; pointer-events: none;
      text-align: center; line-height: 1.6;
    }
  </style>
</head>
<body>

<div id="loading">
  <div>DRONE WARS</div>
  <div style="font-size:14px; color:#888">Loading assets...</div>
</div>

<div id="crosshair"></div>
<div id="hud">
  <div id="hud-drones">DRONES: 0</div>
  <div id="hud-grounded">GROUNDED: YES</div>
  <div id="hud-pos">POS: 0.0, 0.0, 0.0</div>
  <div id="hud-duck">DUCK: NO</div>
  <div id="hud-ammo">SHOTS FIRED: 0</div>
</div>
<div id="info">
  WASD â€” Move &nbsp;|&nbsp; MOUSE â€” Look &nbsp;|&nbsp; SPACE â€” Jump &nbsp;|&nbsp; C â€” Duck &nbsp;|&nbsp; F â€” FreeCam &nbsp;|&nbsp; 0 â€” Spawn Drone &nbsp;|&nbsp; LEFT CLICK â€” Shoot &nbsp;|&nbsp; CLICK â€” Lock Mouse
</div>

<!-- Three.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<!-- Yuka -->
<script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
<!-- Tone.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<!-- Rapier -->
<script type="module">
  import RAPIER from 'https://scottgrocott.github.io/metal_throne/assets/js/rapier3d-compat/rapier.mjs';
  window.RAPIER = RAPIER;
</script>

<script>
// ============================================================
//  DRONE WARS â€” Three.js + Tone.js + Yuka + Rapier
// ============================================================

// ---- CONSTANTS ----
const SCENE_JSON = '/drone_wars/drone_wars_assets_dev.json';
const GROUND_TEX = 'https://scottgrocott.github.io/metal_throne/assets/img/gpt_ground.png';
const LADDER_TEX = 'https://scottgrocott.github.io/metal_throne/assets/img/ladder.png';

// ---- CONFIGURABLE GAME SETTINGS ----
const CONFIG = {
  // Drone launch building origin â€” the "stargate" that must be destroyed
  launchPoint: { x: -13, y: 2, z: 2.8 },

  // How high (world Y) the drone must rise to before engaging pathfinding
  // (set this to clear the top of the smoke stack)
  droneRiseHeight: 8,

  // Drone flight behaviour
  droneMaxSpeed: 5,
  dronePathRadius: 4.0,   // waypoint arrival radius â€” larger = smoother advance through waypoints
  droneFlightHeight: 2.5, // minimum Y height drones fly at (set to clear your ground floor)

  // Freecam / noclip
  freeFlyCamSpeed: 20,   // units per second in freecam

  // ---- SPRITE SCATTER ----
  // Grid layout for each sprite sheet (cols x rows).
  // Tweak these once you can see the sheets in-game.
  sheetGrids: {
    sheet_rocks:  { cols: 4, rows: 2 },   // rocks.png
    sheet_veg:    { cols: 4, rows: 2 },   // vegitation.png
    sheet_veg01:  { cols: 4, rows: 2 },   // vegitation01.png
    sheet_map:    { cols: 4, rows: 4 },   // map-assets.png   (buildings/walls)
    sheet_map01:  { cols: 4, rows: 2 },   // map-assets01.png (stumps)
    sheet_map02:  { cols: 4, rows: 4 },   // map-assets02.png (buildings/walls)
  },

  scatter: {
    // ---- Vegetation (weeds) â€” instanced, maximum density ----
    vegSampleCount: 30000,    // probe rays just for veg â€” processed async in chunks
    vegSteepDensity:  0.9,    // probability on steep faces
    vegFlatDensity:   0.35,   // probability on flat areas (all elevations)
    vegSize: { w: 0.6, h: 0.9 },  // small weeds â€” base size, Â±40% random scale

    // ---- Other props (rocks, stumps, wall boxes) â€” sparse individual meshes ----
    sampleCount: 6000,
    flatRockDensity:   0.10,
    flatStumpDensity:  0.06,
    flatBoxDensity:    0.02,
    buildingRingRadius: 10,    // base radius â€” innermost ring sits right at the building edge
    buildingRingDensity: 0.7,

    // Slope thresholds
    flatThreshold:  0.85,
    steepThreshold: 0.45,
    elevationSplit: 2,

    // Non-veg billboard sizes
    rockSize:  { w: 2.0, h: 1.8 },
    stumpSize: { w: 1.5, h: 2.0 },
    boxSize:   { w: 4.0, h: 5.0 },
  },

  // Gun
  gunRange: 200,
  gunPower: 8,             // knock-back impulse on hit
  bulletSpeed: 60,
  bulletRadius: 0.12,
  bulletLife: 3.0,         // seconds before bullet disappears

  // Drone health
  hitsToDetonate: 10,
};

// ---- PLAYER ----
const PLAYER = {
  height: 1.6, radius: 0.4, mass: 80,
  jumpForce: 1000, moveSpeed: 5000, maxVelocity: 5,
  duckHeight: 0.9,
};

const LADDERS = [
  { position: [-5,    0,    0],      height: 5,  width: .5, climbSpeed: 3 },
  { position: [0,   -0.60296, -9.54734], height: 10, width: 1, climbSpeed: 7 },
  { position: [-11.44083, 0, 1.05525],   height: 8,  width: 1, climbSpeed: 7 },
  { position: [-0.83595, 0, 38.20815],   height: 10, width: 1, climbSpeed: 7 },
];

// ---- THREE.JS SETUP ----
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 100, 800);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);

// ---- LIGHTING â€” midday bright sun ----
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xfffde8, 2.2);
sunLight.position.set(80, 200, 60);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width  = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 1;
sunLight.shadow.camera.far  = 800;
sunLight.shadow.camera.left   = -200;
sunLight.shadow.camera.right  =  200;
sunLight.shadow.camera.top    =  200;
sunLight.shadow.camera.bottom = -200;
sunLight.shadow.bias = -0.0003;
sunLight.shadow.normalBias = 0.02;
scene.add(sunLight);

// Soft fill from sky (hemisphere)
const hemiLight = new THREE.HemisphereLight(0x87CEEB, 0x8B7355, 0.5);
scene.add(hemiLight);

const dirLight = sunLight; // keep dirLight reference for any existing code

// ---- RESIZE ----
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ---- POINTER LOCK ----
const pointerLock = {
  locked: false,
  euler: new THREE.Euler(0, 0, 0, 'YXZ'),
  PI_2: Math.PI / 2
};

document.addEventListener('pointerlockchange', () => {
  pointerLock.locked = document.pointerLockElement === renderer.domElement;
});
document.addEventListener('mousemove', (e) => {
  if (!pointerLock.locked) return;
  const sens = 0.002;
  pointerLock.euler.y -= e.movementX * sens;
  pointerLock.euler.x -= e.movementY * sens;
  pointerLock.euler.x = Math.max(-pointerLock.PI_2, Math.min(pointerLock.PI_2, pointerLock.euler.x));
  camera.quaternion.setFromEuler(pointerLock.euler);
});

// ---- TEXTURE LOADER ----
const texLoader = new THREE.TextureLoader();
const gltfLoader = new THREE.GLTFLoader();

// ---- GROUND ----
const groundTex = texLoader.load(GROUND_TEX);
groundTex.wrapS = groundTex.wrapT = THREE.RepeatWrapping;
groundTex.repeat.set(2250, 2250);
const ground = new THREE.Mesh(
  new THREE.PlaneGeometry(10000, 10000),
  new THREE.MeshStandardMaterial({ map: groundTex, roughness: 0.95, metalness: 0.05, color: 0x8B7355 })
);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;
scene.add(ground);

// ============================================================
//  RAPIER PHYSICS
// ============================================================
let physicsWorld = null;
let physicsReady = false;
let physicsAccumulator = 0;
const PHYSICS_DT = 1 / 60;

async function initPhysics() {
  while (!window.RAPIER) await sleep(100);
  await window.RAPIER.init();
  physicsWorld = new window.RAPIER.World({ x: 0, y: -9.81, z: 0 });
  physicsReady = true;
  console.log('âœ… Rapier physics initialized');

  const R = window.RAPIER;
  const groundBody = physicsWorld.createRigidBody(R.RigidBodyDesc.fixed().setTranslation(0, -0.5, 0));
  physicsWorld.createCollider(R.ColliderDesc.cuboid(5000, 0.5, 5000), groundBody);
}

// All raycasting uses Three.js only â€” zero Rapier/WASM involvement.
// Building meshes collected into raycastMeshes[] as they load.
const raycastMeshes = [];
let _sceneData = null;
let _spriteLoadPromise = Promise.resolve();
const _threeRaycaster = new THREE.Raycaster();
let _rayQueryResults = {};

const WALL_SENSE_DIST = 5.0;
const WALL_AVOID_DIRS = (() => {
  const dirs = [];
  for (let i = 0; i < 8; i++) {
    const a = (i / 8) * Math.PI * 2;
    dirs.push(new THREE.Vector3(Math.cos(a), 0, Math.sin(a)));
  }
  return dirs;
})();

function queryPhysics() {
  _rayQueryResults = {};

  // Player grounded: simple height check against ground plane (yâ‰ˆ0)
  player.isGrounded = playerRig.position.y <= PLAYER.height + 0.25;

  if (!raycastMeshes.length) return;

  for (const drone of drones) {
    if (drone.dead) continue;
    const pos = drone.group.position;
    const result = { wallPush: { x: 0, z: 0 }, detonatorHit: false };

    // 8 horizontal rays for wall avoidance
    for (const dir of WALL_AVOID_DIRS) {
      _threeRaycaster.set(pos, dir);
      _threeRaycaster.far = WALL_SENSE_DIST;
      const hits = _threeRaycaster.intersectObjects(raycastMeshes, false);
      if (hits.length) {
        const d = hits[0].distance;
        const strength = (1 - d / WALL_SENSE_DIST) * 6;
        result.wallPush.x -= dir.x * strength;
        result.wallPush.z -= dir.z * strength;
      }
    }

    // Detonator geometry probe
    if (drone.detonatorArmed) {
      const detWorld = new THREE.Vector3();
      drone.detonatorMesh.getWorldPosition(detWorld);
      const fwd = new THREE.Vector3(0, 0, 1).applyQuaternion(drone.group.quaternion).normalize();
      _threeRaycaster.set(detWorld, fwd);
      _threeRaycaster.far = 0.5;
      const hits = _threeRaycaster.intersectObjects(raycastMeshes, false);
      if (hits.length && hits[0].distance < 0.5) result.detonatorHit = true;
    }

    _rayQueryResults[drone.id] = result;
  }
}

function stepPhysics(dt) {
  if (!physicsReady) return;
  physicsAccumulator += Math.min(dt, 0.1);
  while (physicsAccumulator >= PHYSICS_DT) {
    physicsWorld.step();
    physicsAccumulator -= PHYSICS_DT;
  }
}

// ============================================================
//  DRONE COCKPIT PROPS â€” visible in freecam, attached to camera
// ============================================================
const cockpitGroup = new THREE.Group();
camera.add(cockpitGroup);
cockpitGroup.visible = false;

(function buildCockpit() {
  // Materials â€” match drone aesthetic
  const bodyMat  = new THREE.MeshStandardMaterial({ color: 0x334433, metalness: 0.6, roughness: 0.4 });
  const armMat   = new THREE.MeshStandardMaterial({ color: 0x223322, metalness: 0.7, roughness: 0.3 });
  const rotorMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xff1100, emissiveIntensity: 0.8, metalness: 0.4, roughness: 0.5 });
  const detMat   = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff0000, emissiveIntensity: 1.2, metalness: 0.8, roughness: 0.2 });

  // Body stub â€” partially visible at bottom of screen
  const bodyGeo = new THREE.BoxGeometry(0.22, 0.04, 0.18);
  const body    = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.set(0, -0.14, -0.28);
  cockpitGroup.add(body);

  // Two front arms extending left and right
  const armGeo = new THREE.BoxGeometry(0.28, 0.025, 0.035);

  const armL = new THREE.Mesh(armGeo, armMat);
  armL.position.set(-0.16, -0.13, -0.30);
  armL.rotation.y =  0.22; // angle outward
  cockpitGroup.add(armL);

  const armR = new THREE.Mesh(armGeo, armMat);
  armR.position.set( 0.16, -0.13, -0.30);
  armR.rotation.y = -0.22;
  cockpitGroup.add(armR);

  // Rotor discs on each arm tip
  const rotorGeo = new THREE.CylinderGeometry(0.065, 0.065, 0.008, 10);

  const rotorL = new THREE.Mesh(rotorGeo, rotorMat);
  rotorL.position.set(-0.265, -0.12, -0.36);
  rotorL.userData.isCockpitRotor = true;
  rotorL.userData.spinDir = 1;
  cockpitGroup.add(rotorL);

  const rotorR = new THREE.Mesh(rotorGeo, rotorMat);
  rotorR.position.set( 0.265, -0.12, -0.36);
  rotorR.userData.isCockpitRotor = true;
  rotorR.userData.spinDir = -1;
  cockpitGroup.add(rotorR);

  // Detonator nub on body â€” the "gun barrel" feel
  const detGeo = new THREE.CylinderGeometry(0.018, 0.018, 0.07, 7);
  const det    = new THREE.Mesh(detGeo, detMat);
  det.rotation.x = Math.PI / 2;
  det.position.set(0, -0.13, -0.36);
  cockpitGroup.add(det);
})();

// Cockpit sway state
const cockpitSway = { pitch: 0, roll: 0, bob: 0, bobT: 0 };

function tickCockpit(dt, moveVec) {
  if (!player.freeCam) return;

  // Target pitch/roll from movement direction
  const targetPitch = moveVec.y *  0.08;           // nose dips forward when climbing
  const targetRoll  = -moveVec.x * 0.06;           // bank on strafe
  const lerpT       = Math.min(1, dt * 5);

  cockpitSway.pitch += (targetPitch - cockpitSway.pitch) * lerpT;
  cockpitSway.roll  += (targetRoll  - cockpitSway.roll)  * lerpT;

  // Idle bob
  cockpitSway.bobT += dt * 1.4;
  cockpitSway.bob   = Math.sin(cockpitSway.bobT) * 0.002;

  cockpitGroup.rotation.x = cockpitSway.pitch;
  cockpitGroup.rotation.z = cockpitSway.roll;
  cockpitGroup.position.y = cockpitSway.bob;

  // Spin rotors
  cockpitGroup.children.forEach(c => {
    if (c.userData.isCockpitRotor) {
      c.rotation.y += dt * 28 * c.userData.spinDir;
    }
  });
}


const playerRig = new THREE.Group();
playerRig.position.set(0, PLAYER.height, 0);
playerRig.add(camera);
scene.add(playerRig);

const player = {
  rigidBody: null, collider: null,
  isGrounded: false, justJumped: false,
  onLadder: false, isDucking: false,
  freeCam: false,
  keys: { w:false, s:false, a:false, d:false, space:false, duck:false },
  moveDir: new THREE.Vector3(),
  shotsFired: 0,
};

function initPlayer() {
  const R = window.RAPIER;
  const pos = playerRig.position;
  player.rigidBody = physicsWorld.createRigidBody(
    R.RigidBodyDesc.dynamic()
      .setTranslation(pos.x, pos.y, pos.z)
      .lockRotations()
      .setLinearDamping(5.0)
  );
  player.collider = physicsWorld.createCollider(
    R.ColliderDesc.capsule(PLAYER.height/2 - PLAYER.radius, PLAYER.radius)
      .setMass(PLAYER.mass).setFriction(0).setRestitution(0),
    player.rigidBody
  );
  console.log('âœ… Player physics body created');
}

// Keys
window.addEventListener('keydown', e => {
  if (e.code==='KeyW'||e.code==='ArrowUp')    player.keys.w = true;
  if (e.code==='KeyS'||e.code==='ArrowDown')  player.keys.s = true;
  if (e.code==='KeyA'||e.code==='ArrowLeft')  player.keys.a = true;
  if (e.code==='KeyD'||e.code==='ArrowRight') player.keys.d = true;
  if (e.code==='Space') { player.keys.space = true; e.preventDefault(); }
  if (e.code==='KeyF') {
    player.freeCam = !player.freeCam;
    cockpitGroup.visible = player.freeCam;
    if (player.freeCam) {
      // Freeze physics body so it doesn't fall while flying
      if (player.rigidBody) player.rigidBody.setEnabled(false);
    } else {
      // Re-enable physics and teleport body to current camera position
      if (player.rigidBody) {
        player.rigidBody.setEnabled(true);
        player.rigidBody.setTranslation({ x: playerRig.position.x, y: playerRig.position.y, z: playerRig.position.z }, true);
        player.rigidBody.setLinvel({ x:0, y:0, z:0 }, true);
      }
      // Reset cockpit sway
      cockpitSway.pitch = 0; cockpitSway.roll = 0;
      cockpitGroup.rotation.set(0,0,0);
    }
    console.log('ðŸŽ¥ FreeCam:', player.freeCam ? 'ON' : 'OFF');
  }
  if (e.code==='KeyC') player.keys.duck = true;
  if (e.code==='Digit0' || e.code==='Numpad0') spawnDrone();
});
window.addEventListener('keyup', e => {
  if (e.code==='KeyW'||e.code==='ArrowUp')    player.keys.w = false;
  if (e.code==='KeyS'||e.code==='ArrowDown')  player.keys.s = false;
  if (e.code==='KeyA'||e.code==='ArrowLeft')  player.keys.a = false;
  if (e.code==='KeyD'||e.code==='ArrowRight') player.keys.d = false;
  if (e.code==='Space') { player.keys.space = false; player.justJumped = false; }
  if (e.code==='KeyC') player.keys.duck = false;
});

// Left-click shoot (only when locked)
document.addEventListener('mousedown', async (e) => {
  if (e.button === 0 && !pointerLock.locked) {
    await Tone.start();
    renderer.domElement.requestPointerLock();
    return;
  }
  if (e.button === 0 && pointerLock.locked) {
    shootBullet();
  }
});

function tickPlayer(dt) {
  if (!player.rigidBody) return;

  // ---- FREECAM MODE ----
  if (player.freeCam) {
    const speed = CONFIG.freeFlyCamSpeed;
    const yaw   = pointerLock.euler.y;
    const pitch = pointerLock.euler.x;
    const fwd   = new THREE.Vector3(-Math.sin(yaw)*Math.cos(pitch), Math.sin(pitch), -Math.cos(yaw)*Math.cos(pitch));
    const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
    const move  = new THREE.Vector3();

    if (player.keys.w) move.addScaledVector(fwd, 1);
    if (player.keys.s) move.addScaledVector(fwd, -1);
    if (player.keys.a) move.addScaledVector(right, -1);
    if (player.keys.d) move.addScaledVector(right, 1);
    if (player.keys.space) move.y += 1;     // float up
    if (player.keys.duck)  move.y -= 1;     // float down

    if (move.length() > 0) move.normalize();
    playerRig.position.addScaledVector(move, speed * dt);
    tickCockpit(dt, move);

    const p = playerRig.position;
    document.getElementById('hud-grounded').textContent = 'GROUNDED: FREECAM';
    document.getElementById('hud-duck').textContent     = 'DUCK: â€”';
    document.getElementById('hud-pos').textContent      = `POS: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
    document.getElementById('hud-ammo').textContent     = 'SHOTS FIRED: ' + player.shotsFired;
    return;
  }

  // Duck â€” camera lowers when ducking (was inverted: tippy-toes instead of crouch)
  const wantDuck = player.keys.duck;
  if (wantDuck !== player.isDucking) {
    player.isDucking = wantDuck;
    // Standing: camera at 0 (relative to playerRig which is already at PLAYER.height)
    // Ducking: camera drops by (PLAYER.height - PLAYER.duckHeight)
    camera.position.y = player.isDucking ? -(PLAYER.height - PLAYER.duckHeight) : 0;
  }

  const yaw = pointerLock.euler.y;
  player.moveDir.set(0, 0, 0);
  if (player.keys.w) { player.moveDir.x -= Math.sin(yaw); player.moveDir.z -= Math.cos(yaw); }
  if (player.keys.s) { player.moveDir.x += Math.sin(yaw); player.moveDir.z += Math.cos(yaw); }
  if (player.keys.a) { player.moveDir.x -= Math.cos(yaw); player.moveDir.z += Math.sin(yaw); }
  if (player.keys.d) { player.moveDir.x += Math.cos(yaw); player.moveDir.z -= Math.sin(yaw); }
  if (player.moveDir.length() > 0) player.moveDir.normalize();

  const spd = player.isDucking ? PLAYER.maxVelocity * 0.5 : PLAYER.maxVelocity;
  const vel = _physCache.playerVel; // cached â€” no Rapier borrow
  const hspeed = Math.sqrt(vel.x*vel.x + vel.z*vel.z);
  if (hspeed < spd) {
    player.rigidBody.applyImpulse({
      x: player.moveDir.x * PLAYER.moveSpeed * dt,
      y: 0,
      z: player.moveDir.z * PLAYER.moveSpeed * dt
    }, true);
  }

  if (player.keys.space && player.isGrounded && !player.justJumped && !player.onLadder && !player.isDucking) {
    player.rigidBody.applyImpulse({ x:0, y:PLAYER.jumpForce, z:0 }, true);
    player.justJumped = true;
  }

  // Sync Three.js from cache
  const p = _physCache.playerPos;
  playerRig.position.set(p.x, p.y, p.z);

  document.getElementById('hud-grounded').textContent = 'GROUNDED: ' + (player.isGrounded ? 'YES' : 'NO');
  document.getElementById('hud-duck').textContent = 'DUCK: ' + (player.isDucking ? 'YES' : 'NO');
  document.getElementById('hud-pos').textContent = `POS: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
  document.getElementById('hud-ammo').textContent = 'SHOTS FIRED: ' + player.shotsFired;
}

function checkGrounded() {} // no-op â€” computed in queryPhysics()

// ---- Physics read cache â€” populated once after stepPhysics, used everywhere else ----
// Rule: NEVER call .translation()/.linvel()/.rotation() outside of syncPhysicsReads()
const _physCache = {
  playerPos: { x:0, y:0, z:0 },
  playerVel: { x:0, y:0, z:0 },
  deadDrones: {}, // id -> { pos, rot }
};

function syncPhysicsReads() {
  if (!physicsReady) return;
  try {
    if (player.rigidBody) {
      const p = player.rigidBody.translation();
      const v = player.rigidBody.linvel();
      _physCache.playerPos.x = p.x; _physCache.playerPos.y = p.y; _physCache.playerPos.z = p.z;
      _physCache.playerVel.x = v.x; _physCache.playerVel.y = v.y; _physCache.playerVel.z = v.z;
    }
  } catch(e) {}
  _physCache.deadDrones = {};
  drones.forEach(drone => {
    if (drone.dead && drone.body) {
      try {
        const p = drone.body.translation();
        const r = drone.body.rotation();
        _physCache.deadDrones[drone.id] = {
          pos: { x:p.x, y:p.y, z:p.z },
          rot: { x:r.x, y:r.y, z:r.z, w:r.w }
        };
      } catch(e) {}
    }
  });
}

// ============================================================
//  BUILDINGS
// ============================================================
const buildingBodies = [];

function loadBuildings(data) {
  // Pre-load ground texture for terrain reuse
  const terrainGroundTex = texLoader.load(GROUND_TEX);
  terrainGroundTex.wrapS = terrainGroundTex.wrapT = THREE.RepeatWrapping;
  terrainGroundTex.repeat.set(2250, 2250); // same tiling as the flat ground plane

  data.buildings.forEach(b => {
    const [px, py, pz] = b.position.split(' ').map(Number);
    const [sx, sy, sz] = (b.scale||'1 1 1').split(' ').map(n => Number(n) * (b.class === 'terrain' ? 1 : 1.15));

    const isTerrain = b.class === 'terrain';

    gltfLoader.load(
      b.model.startsWith('#') ? getAssetSrc(data.assets, b.model.slice(1)) : b.model,
      (gltf) => {
        const model = gltf.scene;
        model.position.set(px, py, pz);
        model.scale.set(sx, sy, sz);
        model.traverse(n => {
          if (n.isMesh) {
            n.castShadow  = !isTerrain; // terrain receives but doesn't self-cast (perf)
            n.receiveShadow = true;
            if (isTerrain) {
              // Force the ground texture onto all terrain meshes at the same tiling level
              const mat = new THREE.MeshStandardMaterial({
                map: terrainGroundTex,
                roughness: 0.95,
                metalness: 0.05,
                color: 0x8B7355,
              });
              n.material = mat;
            }
            raycastMeshes.push(n);
          }
        });
        scene.add(model);
        if (!isTerrain) {
          buildStaticCollider(model);
        } else {
          buildStaticCollider(model);
          // Scatter props once terrain geometry AND all sprite textures are ready
          const terrainMeshes = [];
          model.traverse(n => { if (n.isMesh) terrainMeshes.push(n); });
          setTimeout(async () => {
            model.updateWorldMatrix(true, true);
            await _spriteLoadPromise; // guaranteed textures have images
            scatterProps(_sceneData, terrainMeshes);
          }, 200);
        }
        console.log('âœ… ' + (isTerrain ? 'Terrain' : 'Building') + ' loaded:', b.id);
      },
      null,
      (e) => console.error('âŒ Load error:', b.id, e)
    );
  });
}

function getAssetSrc(assets, id) {
  const a = assets.find(a => a.id === id);
  return a ? a.src : null;
}

function buildStaticCollider(model) {
  const R = window.RAPIER;
  const vertices = [];
  const indices  = [];
  let idx = 0;

  model.updateWorldMatrix(true, true);
  model.traverse(node => {
    if (!node.isMesh) return;
    const geo = node.geometry;
    const pos = geo.attributes.position;
    const tmp = new THREE.Vector3();
    for (let i = 0; i < pos.count; i++) {
      tmp.fromBufferAttribute(pos, i).applyMatrix4(node.matrixWorld);
      vertices.push(tmp.x, tmp.y, tmp.z);
    }
    const baseIdx = idx;
    if (geo.index) {
      for (let i = 0; i < geo.index.count; i++) indices.push(baseIdx + geo.index.getX(i));
      idx += pos.count;
    } else {
      for (let i = 0; i < pos.count; i++) indices.push(baseIdx + i);
      idx += pos.count;
    }
  });

  const body = physicsWorld.createRigidBody(R.RigidBodyDesc.fixed());
  physicsWorld.createCollider(
    R.ColliderDesc.trimesh(new Float32Array(vertices), new Uint32Array(indices)),
    body
  );
  buildingBodies.push(body);
  console.log('âœ… Static collider created, triangles:', indices.length / 3);
}

// ============================================================
//  LADDERS
// ============================================================
const ladderTexture = texLoader.load(LADDER_TEX);
const ladderInstances = [];

function initLadders() {
  LADDERS.forEach(def => {
    const [lx, ly, lz] = def.position;
    const mat = new THREE.MeshStandardMaterial({ map: ladderTexture, side: THREE.DoubleSide });
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(def.width, def.height, 0.05), mat);
    mesh.position.set(lx, ly + def.height / 2, lz);
    scene.add(mesh);
    ladderInstances.push({
      position: new THREE.Vector3(lx, ly, lz),
      height: def.height, width: def.width,
      climbSpeed: def.climbSpeed,
      active: false
    });
  });
  console.log('âœ… Ladders initialized:', ladderInstances.length);
}

function tickLadders() {
  if (!player.rigidBody) return;
  const pp = _physCache.playerPos; // cached â€” no Rapier borrow
  const pv = new THREE.Vector3(pp.x, pp.y, pp.z);
  player.onLadder = false;
  ladderInstances.forEach(l => {
    const dx = Math.abs(pv.x - l.position.x);
    const dy = Math.abs(pv.y - (l.position.y + l.height/2));
    const dz = Math.abs(pv.z - l.position.z);
    const on = dx < (l.width/2 + 0.5) && dy < (l.height/2 + 0.5) && dz < 1.0;
    if (on) {
      player.onLadder = true;
      const up = player.keys.w || player.keys.space;
      const dn = player.keys.s;
      if (up || dn) {
        const dir = up ? 1 : -1;
        const vel = _physCache.playerVel; // cached
        player.rigidBody.setLinvel({ x: vel.x*0.5, y: dir*l.climbSpeed, z: vel.z*0.5 }, true);
      }
    }
  });
}

// ============================================================
//  TONE.JS AUDIO
// ============================================================
let toneReady = false;
let windNoise = null;
let windGain = null;

// Pentatonic pitches (Hz) for drone identification â€” each drone gets its own pitch
const DRONE_PITCHES = [110, 130.81, 164.81, 196, 246.94, 293.66, 329.63, 392];

function initAudio() {
  // ---- Environment: wind ----
  try {
    const noiseNode = new Tone.Noise('pink').start();
    const autoFilter = new Tone.AutoFilter({ frequency: '0.1', baseFrequency: 200, octaves: 3 }).start();
    const windEnv = new Tone.Volume(-28);
    noiseNode.connect(autoFilter);
    autoFilter.connect(windEnv);
    windEnv.toDestination();

    // Occasional wind gusts
    function windGust() {
      const t = Tone.now();
      windEnv.volume.rampTo(-20, 2, t);
      windEnv.volume.rampTo(-40, 3, t + 2 + Math.random()*3);
      setTimeout(windGust, 6000 + Math.random() * 12000);
    }
    windGust();

    toneReady = true;
    console.log('âœ… Tone.js audio initialized');
  } catch(e) {
    console.warn('Audio init error:', e);
  }
}

// Create a spatial-ish drone buzz synth
// Uses a sawtooth + distortion + lowpass, panned by position relative to listener
function createDroneSynth(pitchHz, droneIndex) {
  const freq = DRONE_PITCHES[droneIndex % DRONE_PITCHES.length];

  // Layered oscillators for rich buzzing
  const osc1 = new Tone.Oscillator(freq, 'sawtooth');
  const osc2 = new Tone.Oscillator(freq * 1.01, 'square'); // slight detune
  const osc3 = new Tone.Oscillator(freq * 2, 'sawtooth');  // harmonic

  const distortion = new Tone.Distortion(0.4);
  const filter = new Tone.Filter(800, 'lowpass');
  const panner = new Tone.Panner(0);
  const vol = new Tone.Volume(-18);

  osc1.connect(distortion);
  osc2.connect(distortion);
  osc3.connect(distortion);
  distortion.connect(filter);
  filter.connect(panner);
  panner.connect(vol);
  vol.toDestination();

  osc1.start(); osc2.start(); osc3.start();

  return { osc1, osc2, osc3, panner, vol, filter, baseFreq: freq };
}

// Update spatial panning & volume for a drone synth based on 3D position
function updateDroneSpatial(synth, dronePos) {
  if (!synth) return;
  try {
    // Use playerRig (Three.js, no Rapier borrow) instead of rigidBody.translation()
    const pp = playerRig.position;
    const dx = dronePos.x - pp.x;
    const dy = dronePos.y - pp.y;
    const dz = dronePos.z - pp.z;
    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    if (!isFinite(dist) || dist < 0.01) return; // too close or invalid, skip

    // Volume falloff â€” smooth inverse-square-ish curve over a long range
    const maxDist = 120;  // audible out to 120 units (was 50)
    const minVol  = -60;
    const maxVol  = -4;
    // Smooth rolloff: starts at maxVol when very close, falls off gradually
    const normDist = Math.min(dist / maxDist, 1.0);
    const vol = dist < maxDist
      ? maxVol + (minVol - maxVol) * (normDist * normDist)  // quadratic â€” gentle at close range, steeper further out
      : minVol;
    // Use a long time constant (0.8s) so volume changes feel gradual, not snappy
    if (isFinite(vol)) synth.vol.volume.setTargetAtTime(vol, Tone.now(), 0.8);

    // Pan â€” guard zero horizontal length
    const hLen = Math.sqrt(dx*dx + dz*dz);
    if (hLen > 0.01) {
      const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
      const toDrone = new THREE.Vector3(dx / hLen, 0, dz / hLen);
      const pan = Math.max(-1, Math.min(1, toDrone.dot(right)));
      if (isFinite(pan)) synth.panner.pan.setTargetAtTime(pan, Tone.now(), 0.05);
    }

    // Pitch â€” clamp to safe range
    const speed = Math.max(0.5, Math.min(2.0, 1 - dist / 80));
    const f1 = synth.baseFreq * speed;
    const f2 = synth.baseFreq * 1.01 * speed;
    const f3 = synth.baseFreq * 2 * speed;
    if (isFinite(f1) && f1 > 0) {
      synth.osc1.frequency.setTargetAtTime(f1, Tone.now(), 0.2);
      synth.osc2.frequency.setTargetAtTime(f2, Tone.now(), 0.2);
      synth.osc3.frequency.setTargetAtTime(f3, Tone.now(), 0.2);
    }
  } catch(e) {}
}

// Explosion sound synth
function playExplosion(pos) {
  if (!toneReady) return;
  try {
    const noise = new Tone.Noise('white');
    const env   = new Tone.AmplitudeEnvelope({ attack: 0.01, decay: 0.4, sustain: 0, release: 0.5 });
    const dist  = new Tone.Distortion(0.8);
    const filt  = new Tone.Filter(400, 'lowpass');
    const vol   = new Tone.Volume(-6);
    noise.connect(env); env.connect(dist); dist.connect(filt); filt.connect(vol); vol.toDestination();
    noise.start();
    env.triggerAttackRelease('1');
    setTimeout(() => { try { noise.stop(); noise.dispose(); env.dispose(); dist.dispose(); filt.dispose(); vol.dispose(); } catch(e){} }, 2000);
  } catch(e) {}
}

// Gun shot synth
function playGunshot() {
  if (!toneReady) return;
  try {
    const noise = new Tone.Noise('white');
    const env   = new Tone.AmplitudeEnvelope({ attack: 0.001, decay: 0.08, sustain: 0, release: 0.1 });
    const filt  = new Tone.Filter(2000, 'highpass');
    const vol   = new Tone.Volume(-10);
    noise.connect(env); env.connect(filt); filt.connect(vol); vol.toDestination();
    noise.start();
    env.triggerAttackRelease('0.1');
    setTimeout(() => { try { noise.stop(); noise.dispose(); env.dispose(); filt.dispose(); vol.dispose(); } catch(e){} }, 500);
  } catch(e) {}
}

// Bullet hit synth (thud / ding)
function playBulletHit() {
  if (!toneReady) return;
  try {
    const synth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 } });
    synth.toDestination();
    synth.triggerAttackRelease(440, '0.1');
    setTimeout(() => { try { synth.dispose(); } catch(e){} }, 500);
  } catch(e) {}
}

// ============================================================
//  YUKA AI
// ============================================================
const yukaManager = new YUKA.EntityManager();
const yukaTime    = new YUKA.Time();
const flightWaypoints = [];

// ============================================================
//  DRONES
// ============================================================
const drones = [];
let droneCount = 0;

function randomRGB() {
  return new THREE.Color(Math.random(), Math.random() * 0.5 + 0.3, Math.random() * 0.3);
}

function spawnDrone() {
  if (!physicsReady) return;
  const R = window.RAPIER;

  const lp = CONFIG.launchPoint;
  // Spawn exactly at the launch point with no random scatter â€” rises straight up
  const ox = lp.x;
  const oz = lp.z;
  const oy = lp.y;

  const spawnPos = new THREE.Vector3(ox, oy, oz);
  const color = randomRGB();
  const myIndex = droneCount;

  // ---- Visual: body ----
  const group = new THREE.Group();
  group.position.copy(spawnPos);

  const bodyMat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0.6, metalness: 0.3, roughness: 0.5 });
  group.add(new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.25, 1.5), bodyMat));

  // Rotors
  const rotorMat = new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0xff2200, emissiveIntensity: 1 });
  const rotorGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 8);
  [[-0.8,0.15,-0.8],[0.8,0.15,-0.8],[-0.8,0.15,0.8],[0.8,0.15,0.8]].forEach(([x,y,z]) => {
    const r = new THREE.Mesh(rotorGeo, rotorMat);
    r.position.set(x, y, z);
    group.add(r);
  });

  // ---- DETONATOR: cylinder on the front ----
  const detMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff0000, emissiveIntensity: 1.5, metalness: 0.8, roughness: 0.2 });
  const detMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.5, 8), detMat);
  detMesh.rotation.x = Math.PI / 2;
  detMesh.position.set(0, 0, 0.9);
  group.add(detMesh);

  scene.add(group);

  // [REMOVED] spawn marker sphere â€” was debug only

  // ---- Physics (kinematic) ----
  const body = physicsWorld.createRigidBody(
    R.RigidBodyDesc.kinematicPositionBased().setTranslation(ox, oy, oz)
  );
  const collider = physicsWorld.createCollider(
    R.ColliderDesc.ball(0.6).setMass(2).setFriction(0).setRestitution(0.3),
    body
  );

  // ---- Simple manual waypoint follower (no Yuka steering) ----
  let wpIndex = Math.floor(Math.random() * Math.max(1, flightWaypoints.length));
  const vel = new THREE.Vector3(1, 0, 0);
  const pos = new THREE.Vector3(ox, oy, oz);

  // Dummy Yuka vehicle for manager compatibility
  const vehicle = new YUKA.Vehicle();
  vehicle.maxSpeed = CONFIG.droneMaxSpeed;
  vehicle.position.set(ox, oy, oz);
  yukaManager.add(vehicle);

  // Each drone gets a unique height offset so they fly at different levels
  const heightOffset = (droneCount % 5) * 1.2 - 2.4;

  // Drone AI state machine
  // 'rising'  â€” ascending from stargate to clear smoke stack
  // 'patrol'  â€” following waypoints
  // 'hunting' â€” locked onto player, closing in to ram
  let droneState = 'rising';
  let huntCooldown = 0; // seconds remaining on hunt mode after losing LOS

  // Detection raycaster â€” reused per drone
  const detectRay = new THREE.Raycaster();

  function canSeePlayer() {
    const dp = pos;
    const pp = playerRig.position;
    const toPlayer = new THREE.Vector3(pp.x - dp.x, pp.y - dp.y, pp.z - dp.z);
    const dist = toPlayer.length();
    if (dist > 60) return false; // beyond detection range
    toPlayer.normalize();
    detectRay.set(new THREE.Vector3(dp.x, dp.y, dp.z), toPlayer);
    detectRay.far = dist;
    const hits = detectRay.intersectObjects(raycastMeshes, false);
    // No geometry blocking the line of sight
    return hits.length === 0;
  }

  function updateMovement(dt, wallPush) {
    if (!flightWaypoints.length) return;

    // ---- RISE PHASE ----
    if (droneState === 'rising') {
      const targetY = CONFIG.droneRiseHeight;
      const dy = targetY - pos.y;
      const riseSpeed = CONFIG.droneMaxSpeed * 0.6;
      vel.set(0, dy > 0 ? riseSpeed : 0, 0);
      pos.y += vel.y * dt;
      if (pos.y >= targetY) {
        pos.y = targetY;
        droneState = 'patrol';
      }
      group.position.copy(pos);
      try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}
      return;
    }

    // ---- DETECT PLAYER â€” upgrade to hunt ----
    if (droneState === 'patrol') {
      if (canSeePlayer()) {
        droneState = 'hunting';
        huntCooldown = 4.0; // chase for at least 4 seconds after losing sight
      }
    }

    // ---- HUNT MODE ----
    if (droneState === 'hunting') {
      huntCooldown -= dt;
      const pp = playerRig.position;
      const dx = pp.x - pos.x;
      const dy = pp.y - pos.y;
      const dz = pp.z - pos.z;
      const fullDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      const invDist = fullDist > 0.01 ? 1 / fullDist : 0;
      const speed = CONFIG.droneMaxSpeed * 1.6; // faster when hunting

      const desiredX = dx * invDist * speed;
      const desiredY = dy * invDist * speed;
      const desiredZ = dz * invDist * speed;

      const turn = Math.min(1, dt * 5);
      vel.x += (desiredX - vel.x) * turn;
      vel.y += (desiredY - vel.y) * turn;
      vel.z += (desiredZ - vel.z) * turn;

      if (wallPush) { vel.x += wallPush.x * 0.12; vel.z += wallPush.z * 0.12; }

      const spd = vel.length();
      if (spd > speed) vel.multiplyScalar(speed / spd);

      pos.x += vel.x * dt;
      pos.y += vel.y * dt;
      pos.z += vel.z * dt;
      group.position.copy(pos);
      if (spd > 0.1) group.rotation.y = Math.atan2(vel.x, vel.z);
      try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}

      // Revert to patrol if hunt timer runs out and no sight
      if (huntCooldown <= 0 && !canSeePlayer()) {
        droneState = 'patrol';
      }
      return;
    }

    // ---- PATROL MODE ----
    const target = flightWaypoints[wpIndex % flightWaypoints.length];
    const ty = CONFIG.droneFlightHeight + heightOffset;
    const dx = target.x - pos.x;
    const dy = ty - pos.y;
    const dz = target.z - pos.z;
    const dist = Math.sqrt(dx*dx + dz*dz);

    if (dist < CONFIG.dronePathRadius) {
      wpIndex = (wpIndex + 1) % flightWaypoints.length;
    }

    const speed = CONFIG.droneMaxSpeed;
    const fullDist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    const invDist = fullDist > 0.01 ? 1 / fullDist : 0;

    const desiredX = dx * invDist * speed;
    const desiredY = dy * invDist * speed;
    const desiredZ = dz * invDist * speed;

    const turn = Math.min(1, dt * 4);
    vel.x += (desiredX - vel.x) * turn;
    vel.y += (desiredY - vel.y) * turn;
    vel.z += (desiredZ - vel.z) * turn;

    if (wallPush) { vel.x += wallPush.x * 0.15; vel.z += wallPush.z * 0.15; }

    const spd = vel.length();
    if (spd > speed) vel.multiplyScalar(speed / spd);

    pos.x += vel.x * dt;
    pos.y += vel.y * dt;
    pos.z += vel.z * dt;

    group.position.copy(pos);
    if (spd > 0.1) group.rotation.y = Math.atan2(vel.x, vel.z);
    try { body.setNextKinematicTranslation({ x: pos.x, y: pos.y, z: pos.z }); } catch(e) {}
  }

  // ---- Tone.js buzz synth ----
  let synth = null;
  try {
    if (toneReady) synth = createDroneSynth(DRONE_PITCHES[myIndex % DRONE_PITCHES.length], myIndex);
  } catch(e) { console.warn('Synth create error:', e); }

  const drone = {
    group, body, collider, vehicle,
    synth, dead: false, id: ++droneCount,
    hitCount: 0,
    updateMovement,
    detonatorMesh: detMesh,
    color,
    detonatorArmed: false,
    // Expose state so external code (e.g. bullet hits) can trigger hunt mode
    getState: () => droneState,
    triggerHunt: () => { droneState = 'hunting'; huntCooldown = 6.0; },
  };
  // Arm after 2.5s â€” enough time to rise clear of launch geometry
  setTimeout(() => { if (!drone.dead) drone.detonatorArmed = true; }, 2500);

  drones.push(drone);
  document.getElementById('hud-drones').textContent = 'DRONES: ' + drones.filter(d=>!d.dead).length;
  console.log('ðŸ›¸ Drone spawned #' + drone.id, 'at', ox.toFixed(2), oy.toFixed(2), oz.toFixed(2));
}

// ============================================================
//  EXPLOSION / SMOKE / FIRE PARTICLE SYSTEM
// ============================================================
const activeEffects = [];

// ---- Generate soft circular canvas textures ----
function makeParticleTex(innerColor, outerColor, size = 64) {
  const c   = document.createElement('canvas');
  c.width   = size; c.height = size;
  const ctx = c.getContext('2d');
  const r   = size / 2;
  const grd = ctx.createRadialGradient(r, r, 0, r, r, r);
  grd.addColorStop(0,   innerColor);
  grd.addColorStop(0.4, outerColor);
  grd.addColorStop(1,   'rgba(0,0,0,0)');
  ctx.fillStyle = grd;
  ctx.fillRect(0, 0, size, size);
  return new THREE.CanvasTexture(c);
}

// Pre-bake textures once
const _texFireCore  = makeParticleTex('rgba(255,255,220,1)',  'rgba(255,160,0,0.7)');
const _texFireMid   = makeParticleTex('rgba(255,120,0,0.95)', 'rgba(200,40,0,0.5)');
const _texFlame     = makeParticleTex('rgba(255,80,0,0.9)',   'rgba(255,200,0,0.4)');
const _texSmokeLt   = makeParticleTex('rgba(180,170,160,0.7)','rgba(120,115,110,0.0)');
const _texSmokeDk   = makeParticleTex('rgba(60,55,50,0.8)',   'rgba(30,28,25,0.0)');
const _texEmber     = makeParticleTex('rgba(255,240,80,1)',    'rgba(255,100,0,0.0)', 32);

// Shared unit-quad geometry
const _pGeo = new THREE.PlaneGeometry(1, 1);

// ---- Material factory â€” NormalBlending for all, texture does the softness ----
function makePartMat(tex, opacity) {
  return new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity,
    depthWrite: false,
    side: THREE.DoubleSide,
    blending: THREE.NormalBlending,
  });
}

// ---- One particle ----
function makeParticle(tex, pos, vel, life, size, growRate, fadeStart) {
  const mat  = makePartMat(tex, 1.0);
  const mesh = new THREE.Mesh(_pGeo, mat);
  mesh.position.copy(pos);
  mesh.scale.setScalar(size);
  // Random initial spin for variety
  mesh.rotation.z = Math.random() * Math.PI * 2;
  return { mesh, vel: vel.clone(), life, maxLife: life, size, growRate, fadeStart, mat };
}

// ---- FIREBALL burst ----
function spawnFireball(group) {
  const particles = [];
  for (let i = 0; i < 32; i++) {
    const isCore = i < 10;
    const tex    = isCore ? _texFireCore : _texFireMid;
    const vel    = new THREE.Vector3(
      (Math.random()-0.5) * 7,
      Math.random() * 6 + 2,
      (Math.random()-0.5) * 7
    );
    const size = isCore ? 1.0 + Math.random()*1.2 : 0.5 + Math.random()*0.9;
    const life = 0.25 + Math.random() * 0.45;
    const p    = makeParticle(tex, new THREE.Vector3(), vel, life, size, 2.5, 0.5);
    group.add(p.mesh);
    particles.push(p);
  }
  return particles;
}

// ---- Sustained flames ----
function spawnFlames(group) {
  const particles = [];
  for (let i = 0; i < 20; i++) {
    const vel = new THREE.Vector3(
      (Math.random()-0.5) * 1.4,
      2.0 + Math.random() * 3.0,
      (Math.random()-0.5) * 1.4
    );
    const size = 0.5 + Math.random() * 0.7;
    const life = 0.4 + Math.random() * 0.6;
    const p    = makeParticle(_texFlame, new THREE.Vector3(
      (Math.random()-0.5)*0.3, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.3
    ), vel, life, size, 1.2, 0.4);
    group.add(p.mesh);
    particles.push(p);
  }
  return particles;
}

// ---- Smoke puffs â€” trail downward toward ground ----
function spawnSmokePuff(offset, group) {
  const particles = [];
  for (let i = 0; i < 8; i++) {
    const isDark = Math.random() < 0.5;
    const tex    = isDark ? _texSmokeDk : _texSmokeLt;
    const vel    = new THREE.Vector3(
      (Math.random()-0.5) * 1.0,
      -0.6 - Math.random() * 1.8,   // downward smoke trail
      (Math.random()-0.5) * 1.0
    );
    const size = 0.6 + Math.random() * 1.0;
    const life = 1.0 + Math.random() * 1.2;
    const pos  = offset.clone().add(new THREE.Vector3(
      (Math.random()-0.5)*0.5, 0, (Math.random()-0.5)*0.5
    ));
    const p = makeParticle(tex, pos, vel, life, size, 3.0, 0.3);
    group.add(p.mesh);
    particles.push(p);
  }
  return particles;
}

// ---- Embers â€” bright tiny sparks ----
function spawnEmbers(group) {
  const particles = [];
  for (let i = 0; i < 24; i++) {
    const vel = new THREE.Vector3(
      (Math.random()-0.5) * 11,
      Math.random() * 9 + 2,
      (Math.random()-0.5) * 11
    );
    const size = 0.08 + Math.random() * 0.14;
    const life = 0.7 + Math.random() * 1.6;
    const p    = makeParticle(_texEmber, new THREE.Vector3(), vel, life, size, 0, 0.6);
    group.add(p.mesh);
    particles.push(p);
  }
  return particles;
}

// ---- Main effect spawner ----
function spawnExplosionEffect(droneGroup) {
  const fxGroup = new THREE.Group();
  droneGroup.add(fxGroup);

  const fireball = spawnFireball(fxGroup);
  const embers   = spawnEmbers(fxGroup);

  let flamesSpawned = false;
  let smokeTimer    = 0;
  let elapsed       = 0;
  const totalLife   = 5.0;
  const allParticles    = [...fireball, ...embers];
  const flameParticles  = [];

  activeEffects.push({
    fxGroup, allParticles, flameParticles,
    smokeTimer, flamesSpawned, elapsed, totalLife,

    update(dt) {
      this.elapsed += dt;
      const t = this.elapsed;
      const gravity = -3.5;

      // Spawn flames at ~0.05s
      if (!this.flamesSpawned && t > 0.05) {
        this.flamesSpawned = true;
        const fp = spawnFlames(fxGroup);
        this.flameParticles.push(...fp);
        this.allParticles.push(...fp);
      }

      // Recycle flame particles while fire is alive
      if (t < 3.8) {
        for (const p of this.flameParticles) {
          if (p.life <= 0) {
            p.mesh.visible = true;
            p.mesh.position.set(
              (Math.random()-0.5)*0.4,
              (Math.random()-0.5)*0.2,
              (Math.random()-0.5)*0.4
            );
            p.vel.set(
              (Math.random()-0.5)*1.4,
              2.0 + Math.random()*3.0,
              (Math.random()-0.5)*1.4
            );
            p.life    = 0.4 + Math.random()*0.6;
            p.maxLife = p.life;
            p.size    = 0.5 + Math.random()*0.7;
            p.mesh.scale.setScalar(p.size);
            p.mat.opacity = 1.0;
          }
        }
      }

      // Periodic smoke
      this.smokeTimer += dt;
      if (t < 4.2 && this.smokeTimer >= 0.07) {
        this.smokeTimer = 0;
        const offset = new THREE.Vector3(
          (Math.random()-0.5)*0.3, -0.1, (Math.random()-0.5)*0.3
        );
        const sp = spawnSmokePuff(offset, fxGroup);
        this.allParticles.push(...sp);
      }

      // Tick all
      for (const p of this.allParticles) {
        if (p.life <= 0) continue;
        p.life -= dt;
        const norm = Math.max(0, p.life / p.maxLife);

        p.mesh.position.x += p.vel.x * dt;
        p.mesh.position.y += p.vel.y * dt;
        p.mesh.position.z += p.vel.z * dt;
        p.vel.y += gravity * dt;

        // Grow
        const s = p.size * (1 + p.growRate * (1 - norm));
        p.mesh.scale.setScalar(s);

        // Fade â€” hold opacity until fadeStart fraction of life remains
        const fadeNorm = norm < p.fadeStart ? norm / p.fadeStart : 1.0;
        p.mat.opacity = fadeNorm;

        // Slow spin
        p.mesh.rotation.z += dt * 0.4 * (p.size > 0.5 ? 1 : -1);

        // Billboard
        p.mesh.rotation.y = pointerLock.euler.y + Math.PI;

        if (p.life <= 0) p.mesh.visible = false;
      }
    }
  });
}



// Tick all active explosion effects â€” called from main loop
function tickExplosions(dt) {
  for (let i = activeEffects.length - 1; i >= 0; i--) {
    const fx = activeEffects[i];
    fx.update(dt);
    if (fx.elapsed >= fx.totalLife) {
      // Cleanup handled by killDrone's setTimeout â€” just remove from list
      activeEffects.splice(i, 1);
    }
  }
}


function killDrone(drone, fromDetonator = false) {
  if (drone.dead) return;
  drone.dead = true;

  const R = window.RAPIER;
  const pos = drone.group.position;

  playExplosion(pos);
  spawnExplosionEffect(drone.group);

  drone.group.traverse(n => {
    if (n.isMesh && n.material) {
      n.material = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0xff4400, emissiveIntensity: 3 });
    }
  });

  yukaManager.remove(drone.vehicle);

  const oldC = drone.collider;
  const oldB = drone.body;

  drone.body = physicsWorld.createRigidBody(
    R.RigidBodyDesc.dynamic().setTranslation(pos.x, pos.y, pos.z)
  );
  drone.collider = physicsWorld.createCollider(
    R.ColliderDesc.cuboid(0.5, 0.5, 0.5).setMass(2).setRestitution(0.3).setFriction(0.5),
    drone.body
  );
  drone.body.setLinvel({ x:(Math.random()-0.5)*8, y:5, z:(Math.random()-0.5)*8 }, true);
  drone.body.setAngvel({ x:(Math.random()-0.5)*10, y:(Math.random()-0.5)*10, z:(Math.random()-0.5)*10 }, true);

  setTimeout(() => {
    try { physicsWorld.removeCollider(oldC, true); } catch(e){}
    try { physicsWorld.removeRigidBody(oldB); } catch(e){}
  }, 50);

  if (drone.synth) {
    try {
      drone.synth.osc1.stop(); drone.synth.osc2.stop(); drone.synth.osc3.stop();
      setTimeout(() => {
        try { drone.synth.osc1.dispose(); drone.synth.osc2.dispose(); drone.synth.osc3.dispose();
              drone.synth.panner.dispose(); drone.synth.vol.dispose(); drone.synth.filter.dispose(); } catch(e){}
      }, 200);
    } catch(e) {}
    drone.synth = null;
  }

  setTimeout(() => {
    scene.remove(drone.group);
    try { physicsWorld.removeCollider(drone.collider, true); } catch(e){}
    try { physicsWorld.removeRigidBody(drone.body); } catch(e){}
    const idx = drones.indexOf(drone);
    if (idx >= 0) drones.splice(idx, 1);
    document.getElementById('hud-drones').textContent = 'DRONES: ' + drones.filter(d=>!d.dead).length;
  }, 5000);

  console.log('ðŸ’¥ Drone killed #' + drone.id);
}


function tickDrones(dt) {
  drones.forEach(drone => {
    if (drone.dead && drone.body) {
      const cached = _physCache.deadDrones[drone.id];
      if (cached) {
        drone.group.position.set(cached.pos.x, cached.pos.y, cached.pos.z);
        drone.group.quaternion.set(cached.rot.x, cached.rot.y, cached.rot.z, cached.rot.w);
      }
      return;
    }

    if (!drone.dead) {
      // Move drone â€” pass wall avoidance results from pre-queried raycasts
      const qr = _rayQueryResults[drone.id];
      drone.updateMovement(dt, qr ? qr.wallPush : null);

      if (drone.synth) updateDroneSpatial(drone.synth, drone.group.position);

      // Spin rotors
      drone.group.children.forEach((child, i) => {
        if (i >= 1 && i <= 4) child.rotation.y += dt * 20 * (1 + drone.id * 0.3);
      });

      // Detonator checks (only when armed)
      if (drone.detonatorArmed) checkDetonatorCollision(drone);
    }
  });
}

// Detonator collision â€” proximity for player/drones, cached raycast for geometry
function checkDetonatorCollision(drone) {
  if (!player.rigidBody) return;

  const detWorld = new THREE.Vector3();
  drone.detonatorMesh.getWorldPosition(detWorld);

  // --- vs player (use playerRig â€” no Rapier borrow) ---
  const pp = playerRig.position;
  if ((detWorld.x-pp.x)**2+(detWorld.y-pp.y)**2+(detWorld.z-pp.z)**2 < 0.64) {
    console.log('ðŸ’€ Player hit by detonator!');
    killDrone(drone, true);
    return;
  }

  // --- vs other drones (no Rapier needed) ---
  for (const other of drones) {
    if (other === drone || other.dead) continue;
    const op = other.group.position;
    if ((detWorld.x-op.x)**2+(detWorld.y-op.y)**2+(detWorld.z-op.z)**2 < 1.44) {
      killDrone(drone, true);
      killDrone(other, true);
      return;
    }
  }

  // --- vs geometry (use pre-queried results, no live castRay here) ---
  const result = _rayQueryResults[drone.id];
  if (result && result.detonatorHit) {
    console.log('ðŸ’¥ Detonator hit geometry!');
    killDrone(drone, true);
  }
}

// ============================================================
//  BULLETS / GUN
// ============================================================
const bullets = [];

function shootBullet() {
  if (!physicsReady) return;
  if (!toneReady) { Tone.start().catch(()=>{}); }

  playGunshot();
  player.shotsFired++;

  const R = window.RAPIER;

  // Bullet starts at camera world position
  const origin = new THREE.Vector3();
  camera.getWorldPosition(origin);

  // Direction = where camera is looking
  const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).normalize();

  // Visual sphere
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(CONFIG.bulletRadius, 6, 6),
    new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffaa00, emissiveIntensity: 2 })
  );
  mesh.position.copy(origin);
  scene.add(mesh);

  // Physics â€” kinematic bullet (we move it manually for simplicity)
  const bullet = {
    mesh,
    dir: dir.clone(),
    speed: CONFIG.bulletSpeed,
    life: CONFIG.bulletLife,
    dead: false,
  };
  bullets.push(bullet);
}

function tickBullets(dt) {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    if (b.dead) { bullets.splice(i, 1); continue; }

    b.life -= dt;
    if (b.life <= 0) {
      scene.remove(b.mesh);
      b.dead = true;
      bullets.splice(i, 1);
      continue;
    }

    // Move bullet
    const move = b.dir.clone().multiplyScalar(b.speed * dt);
    b.mesh.position.add(move);

    // Check collision with drones
    let hitSomething = false;
    drones.forEach(drone => {
      if (drone.dead || hitSomething) return;
      const dp = drone.group.position;
      const bp = b.mesh.position;
      const dist = bp.distanceTo(dp);

      if (dist < 1.0) {
        // Check if detonator was hit (closer to front)
        const detWorld = new THREE.Vector3();
        drone.detonatorMesh.getWorldPosition(detWorld);
        const detDist = bp.distanceTo(detWorld);

        if (detDist < 0.35) {
          // Direct detonator hit â€” instant kill
          killDrone(drone);
        } else {
          // Body hit â€” bump + increment hit counter + ALERT the drone to hunt player
          drone.hitCount++;
          playBulletHit();
          drone.triggerHunt(); // drone spins and hunts the player

          // Bump the drone visually/physically â€” offset its vehicle position
          const knockDir = new THREE.Vector3(b.dir.x, 0.5, b.dir.z).normalize();
          const ent = drone.vehicle;
          ent.position.x += knockDir.x * 0.5;
          ent.position.y += knockDir.y * 0.3;
          ent.position.z += knockDir.z * 0.5;

          // Flash
          drone.group.children.forEach(child => {
            if (child.isMesh) {
              const origMat = child.material;
              child.material = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 3 });
              setTimeout(() => { child.material = origMat; }, 80);
            }
          });

          if (drone.hitCount >= CONFIG.hitsToDetonate) {
            killDrone(drone);
          }
        }

        hitSomething = true;
      }
    });

    if (hitSomething) {
      scene.remove(b.mesh);
      b.dead = true;
      bullets.splice(i, 1);
    }
  }
}

// ============================================================
//  SPRITE SCATTER SYSTEM
// ============================================================
// Billboards that face the camera, cut from sprite sheet atlases.
// Placed after terrain loads by sampling the terrain geometry.

const scatterGroup = new THREE.Group();
scene.add(scatterGroup);

// Loaded atlas textures keyed by sheet id
const atlasTextures = {};

// Load all spritesheet textures from the JSON assets array.
// Returns a Promise that resolves once every sheet has loaded.
function loadSpriteAssets(assets) {
  const sheets = assets.filter(a => a.type === 'spritesheet');
  if (!sheets.length) return Promise.resolve();

  return new Promise(resolve => {
    let remaining = sheets.length;
    sheets.forEach(a => {
      texLoader.load(
        a.src,
        (tex) => {
          // onLoad â€” image is now available
          tex.encoding = THREE.sRGBEncoding;
          atlasTextures[a.id] = { tex, category: a.category, id: a.id };
          console.log('ðŸŒ¿ Sprite sheet loaded:', a.id);
          remaining--;
          if (remaining === 0) resolve();
        },
        undefined,
        (err) => {
          // onError â€” still decrement so we don't hang forever
          console.warn('âš ï¸ Sprite sheet failed:', a.id, err);
          remaining--;
          if (remaining === 0) resolve();
        }
      );
    });
  });
}

// Pick a random sprite cell from a sheet and return a cropped material.
// Only call this AFTER loadSpriteAssets() has resolved.
function makeBillboardMat(sheetId) {
  const entry = atlasTextures[sheetId];
  if (!entry || !entry.tex.image) return null;
  const grid = CONFIG.sheetGrids[sheetId] || { cols: 4, rows: 2 };
  const col = Math.floor(Math.random() * grid.cols);
  const row = Math.floor(Math.random() * grid.rows);
  const t = entry.tex.clone();
  t.needsUpdate = true;
  t.repeat.set(1 / grid.cols, 1 / grid.rows);
  t.offset.set(col / grid.cols, 1 - (row + 1) / grid.rows);
  return new THREE.MeshBasicMaterial({
    map: t, transparent: true, alphaTest: 0.15,
    depthWrite: false, side: THREE.DoubleSide,
  });
}

// ---- Individual billboard (rocks, stumps, boxes) ----
function makeBillboard(sheetId, worldPos, w, h) {
  const mat = makeBillboardMat(sheetId);
  if (!mat) return null;
  const geo  = new THREE.PlaneGeometry(w, h);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.copy(worldPos);
  mesh.position.y += h * 0.5;
  mesh.userData.isBillboard = true;
  scatterGroup.add(mesh);
  return mesh;
}

// ============================================================
//  INSTANCED VEGETATION SYSTEM
//  One InstancedMesh per unique sprite cell = one draw call each.
//  Handles tens of thousands of weeds cheaply.
// ============================================================
const vegInstances = [];   // { mesh: InstancedMesh, count, capacity, dummy }
const _vegDummy    = new THREE.Object3D();

function getVegSheetCells(data) {
  // Build list of all unique {sheetId, col, row} combos for veg sheets
  const cells = [];
  data.assets.filter(a => a.type === 'spritesheet' && a.category === 'vegetation').forEach(a => {
    const grid = CONFIG.sheetGrids[a.id] || { cols: 4, rows: 2 };
    for (let r = 0; r < grid.rows; r++) {
      for (let c = 0; c < grid.cols; c++) {
        cells.push({ sheetId: a.id, col: c, row: r, grid });
      }
    }
  });
  return cells;
}

function buildVegInstancedMeshes(data, capacity) {
  // capacity = max instances per cell â€” pre-allocate
  const cells = getVegSheetCells(data);
  if (!cells.length) return;

  const geo = new THREE.PlaneGeometry(1, 1); // unit plane â€” scale via matrix

  cells.forEach(cell => {
    const entry = atlasTextures[cell.sheetId];
    if (!entry || !entry.tex.image) return;

    const t = entry.tex.clone();
    t.needsUpdate = true;
    t.repeat.set(1 / cell.grid.cols, 1 / cell.grid.rows);
    t.offset.set(cell.col / cell.grid.cols, 1 - (cell.row + 1) / cell.grid.rows);

    const mat = new THREE.MeshBasicMaterial({
      map: t, transparent: true, alphaTest: 0.15,
      depthWrite: false, side: THREE.DoubleSide,
    });

    const mesh = new THREE.InstancedMesh(geo, mat, capacity);
    mesh.count = 0; // start empty â€” filled during scatter
    mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    mesh.frustumCulled = false; // we do our own culling via visibility
    scatterGroup.add(mesh);

    vegInstances.push({ mesh, count: 0, capacity, cellKey: `${cell.sheetId}_${cell.col}_${cell.row}` });
  });

  console.log(`ðŸŒ¿ Instanced veg meshes created: ${vegInstances.length} cells, ${capacity} capacity each`);
}

// Add one weed instance â€” picks a random cell mesh, sets matrix
function addVegInstance(worldX, worldY, worldZ, w, h) {
  if (!vegInstances.length) return;
  const si   = Math.floor(Math.random() * vegInstances.length);
  const slot = vegInstances[si];
  if (slot.count >= slot.capacity) return;

  _vegDummy.position.set(worldX, worldY + h * 0.5, worldZ);
  _vegDummy.scale.set(w, h, 1);
  _vegDummy.rotation.y = 0;
  _vegDummy.updateMatrix();
  slot.mesh.setMatrixAt(slot.count, _vegDummy.matrix);
  slot.count++;
  slot.mesh.count = slot.count;
  slot.mesh.instanceMatrix.needsUpdate = true;

  // Record for fast per-frame rotation updates
  recordVegInstanceData(si, worldX, worldY, worldZ, w, h);
}

// ---- Terrain raycast helper ----
const _scatterRay = new THREE.Raycaster();
const _up         = new THREE.Vector3(0, 1, 0);

function sampleTerrainAt(x, z, terrainMeshes) {
  _scatterRay.set(new THREE.Vector3(x, 300, z), new THREE.Vector3(0, -1, 0));
  _scatterRay.far = 600;
  const hits = _scatterRay.intersectObjects(terrainMeshes, false);
  if (!hits.length) return null;
  const h = hits[0];
  const normal = h.face
    ? h.face.normal.clone().transformDirection(h.object.matrixWorld).normalize()
    : _up.clone();
  return { y: h.point.y, normal };
}

// Building positions for perimeter ring
const buildingPositions = [];

// ---- Main scatter entry point â€” called after terrain + sprites both ready ----
async function scatterProps(data, terrainMeshes) {
  const SC  = CONFIG.scatter;
  const rng = (min, max) => min + Math.random() * (max - min);

  const byCategory = {};
  data.assets.filter(a => a.type === 'spritesheet').forEach(a => {
    if (!byCategory[a.category]) byCategory[a.category] = [];
    byCategory[a.category].push(a.id);
  });
  const rockSheets  = byCategory['rocks']     || [];
  const stumpSheets = byCategory['stumps']    || [];
  const wallSheets  = byCategory['buildings'] || [];
  function randSheet(arr) { return arr.length ? arr[Math.floor(Math.random()*arr.length)] : null; }

  // Compute terrain bounding box
  const terrainBox = new THREE.Box3();
  terrainMeshes.forEach(m => { m.updateWorldMatrix(true,false); terrainBox.union(new THREE.Box3().setFromObject(m)); });
  const bmin = terrainBox.min, bmax = terrainBox.max;
  const bw = bmax.x - bmin.x, bd = bmax.z - bmin.z;
  console.log(`ðŸ—ºï¸ Terrain bbox: X[${bmin.x.toFixed(1)}â†’${bmax.x.toFixed(1)}] Z[${bmin.z.toFixed(1)}â†’${bmax.z.toFixed(1)}]`);

  // =========================================================
  //  PASS 1 â€” VEGETATION (instanced, async chunked)
  // =========================================================
  const vegCells  = Math.ceil(Math.sqrt(SC.vegSampleCount));
  const vegCellW  = bw / vegCells;
  const vegCellD  = bd / vegCells;
  const CHUNK     = 60; // rows per frame â€” keeps hang under ~16ms
  let vegPlaced   = 0;

  // Pre-build instanced meshes with capacity estimate
  const estVeg = Math.ceil(SC.vegSampleCount * SC.vegFlatDensity * 1.8);
  buildVegInstancedMeshes(data, estVeg);

  // Process in async row chunks
  for (let gx = 0; gx < vegCells; gx++) {
    if (gx % CHUNK === 0) {
      // Yield to browser â€” keeps UI responsive during build
      await new Promise(r => setTimeout(r, 0));
    }
    for (let gz = 0; gz < vegCells; gz++) {
      const x = bmin.x + (gx + Math.random()) * vegCellW;
      const z = bmin.z + (gz + Math.random()) * vegCellD;
      const s = sampleTerrainAt(x, z, terrainMeshes);
      if (!s) continue;

      const slopeUp = s.normal.dot(_up);
      const eligible = slopeUp <= SC.steepThreshold
        ? Math.random() < SC.vegSteepDensity
        : (slopeUp >= SC.flatThreshold ? Math.random() < SC.vegFlatDensity : false);

      if (eligible) {
        const scale = rng(0.6, 1.4);
        addVegInstance(x, s.y, z, SC.vegSize.w * scale, SC.vegSize.h * scale);
        // Double-up on steep faces for crevasse fill
        if (slopeUp <= SC.steepThreshold && Math.random() < 0.6) {
          addVegInstance(x + rng(-0.8,0.8), s.y, z + rng(-0.8,0.8),
            SC.vegSize.w * rng(0.5,1.1), SC.vegSize.h * rng(0.5,1.1));
        }
        vegPlaced++;
      }
    }
  }
  console.log(`ðŸŒ¿ Veg instances placed: ${vegPlaced}`);

  // =========================================================
  //  PASS 2 â€” ROCKS / STUMPS / BOXES (individual, sparse)
  // =========================================================
  const propCells = Math.ceil(Math.sqrt(SC.sampleCount));
  const propCellW = bw / propCells;
  const propCellD = bd / propCells;
  let propPlaced  = 0;

  for (let gx = 0; gx < propCells; gx++) {
    if (gx % CHUNK === 0) await new Promise(r => setTimeout(r, 0));
    for (let gz = 0; gz < propCells; gz++) {
      const x = bmin.x + (gx + Math.random()) * propCellW;
      const z = bmin.z + (gz + Math.random()) * propCellD;
      const s = sampleTerrainAt(x, z, terrainMeshes);
      if (!s) continue;

      const slopeUp    = s.normal.dot(_up);
      const isFlat     = slopeUp >= SC.flatThreshold;
      const isElevated = s.y > SC.elevationSplit;
      if (!isFlat) continue; // rocks/stumps/boxes only on flat

      const roll = Math.random();
      const pos  = new THREE.Vector3(x, s.y, z);

      if (isElevated) {
        if (roll < SC.flatRockDensity && rockSheets.length) {
          const r = SC.rockSize;
          makeBillboard(randSheet(rockSheets), pos, r.w * rng(0.8,1.5), r.h * rng(0.7,1.3));
          propPlaced++;
        } else if (roll < SC.flatRockDensity + SC.flatStumpDensity && stumpSheets.length) {
          const r = SC.stumpSize;
          makeBillboard(randSheet(stumpSheets), pos, r.w * rng(0.8,1.2), r.h * rng(0.8,1.2));
          propPlaced++;
        } else if (roll < SC.flatRockDensity + SC.flatStumpDensity + SC.flatBoxDensity && wallSheets.length) {
          const r = SC.boxSize;
          makeBillboard(randSheet(wallSheets), pos, r.w * rng(0.7,1.3), r.h * rng(0.7,1.3));
          propPlaced++;
        }
      } else {
        if (roll < SC.flatBoxDensity && wallSheets.length) {
          const r = SC.boxSize;
          makeBillboard(randSheet(wallSheets), pos, r.w * rng(0.8,1.4), r.h * rng(0.8,1.4));
          propPlaced++;
        }
      }
    }
  }

  // ---- Building perimeter seam fill â€” rectangular edge walking ----
  // Walk along each of the 4 sides of the building's bounding rectangle,
  // placing weeds in multiple inset layers so the seam disappears.
  buildingPositions.forEach(bp => {
    // Use stored half-extents, fall back to buildingRingRadius if missing
    const hx = bp.hx || SC.buildingRingRadius;
    const hz = bp.hz || SC.buildingRingRadius;

    // Layers: offset from wall face (negative = inside footprint, positive = outside)
    // Innermost layer right at the edge, then stepping outward
    const layers = [
      { offset: -0.5, density: 1.00, sizeMin: 1.1, sizeMax: 2.4, spacing: 0.9 },
      { offset:  0.5, density: 0.98, sizeMin: 0.9, sizeMax: 2.0, spacing: 1.0 },
      { offset:  1.8, density: 0.85, sizeMin: 0.7, sizeMax: 1.6, spacing: 1.2 },
      { offset:  3.5, density: 0.65, sizeMin: 0.5, sizeMax: 1.2, spacing: 1.6 },
      { offset:  6.0, density: 0.35, sizeMin: 0.4, sizeMax: 0.9, spacing: 2.2 },
    ];

    // Helper: place a weed at (wx, wz) terrain-snapped
    function placeWeed(wx, wz, sizeMin, sizeMax) {
      const s  = sampleTerrainAt(wx, wz, terrainMeshes);
      const wy = s ? s.y : bp.y;
      const sc = rng(sizeMin, sizeMax);
      addVegInstance(wx, wy, wz, SC.vegSize.w * sc, SC.vegSize.h * sc);
      propPlaced++;
    }

    layers.forEach(layer => {
      const ox = hx + layer.offset;  // offset rect half-width
      const oz = hz + layer.offset;  // offset rect half-depth
      const sp = layer.spacing;

      // Walk all 4 sides
      // North edge (z = -oz), East (x = +ox), South (z = +oz), West (x = -ox)
      const sides = [
        { axis: 'x', from: -ox, to: ox,  fixed: -oz, fx: false },
        { axis: 'x', from: -ox, to: ox,  fixed: +oz, fx: false },
        { axis: 'z', from: -oz, to: oz,  fixed: -ox, fx: true  },
        { axis: 'z', from: -oz, to: oz,  fixed: +ox, fx: true  },
      ];

      sides.forEach(side => {
        const len   = side.to - side.from;
        const steps = Math.ceil(len / sp);
        for (let i = 0; i <= steps; i++) {
          if (Math.random() > layer.density) continue;
          // Position along this side with sub-spacing jitter
          const t    = side.from + (i / steps) * len + rng(-sp * 0.35, sp * 0.35);
          // Small perpendicular jitter so it doesn't look like a perfect line
          const perp = rng(-0.6, 0.6);
          const wx   = bp.x + (side.fx ? side.fixed + perp : t);
          const wz   = bp.z + (side.fx ? t : side.fixed + perp);
          placeWeed(wx, wz, layer.sizeMin, layer.sizeMax);
        }
      });
    });
  });

  console.log(`ðŸª¨ Props placed: ${propPlaced}`);
}

// ============================================================
//  FRUSTUM CULLING + BILLBOARD FACING
// ============================================================
const _billboardFrustum    = new THREE.Frustum();
const _billboardProjMatrix = new THREE.Matrix4();
const _iPos  = new THREE.Vector3();
const _iQuat = new THREE.Quaternion();
const _iScl  = new THREE.Vector3();
const _iMat  = new THREE.Matrix4();

// Cache per-slot: flat arrays of [x,y,z, sx,sy] for each instance
// Built once during scatter, reused every frame for rotation updates
const vegInstanceData = []; // parallel to vegInstances: Float32Array [x,y,z,sx,sy, ...]

// Called by addVegInstance to also record position/scale for fast frame updates
function recordVegInstanceData(slotIndex, x, y, z, w, h) {
  if (!vegInstanceData[slotIndex]) vegInstanceData[slotIndex] = [];
  vegInstanceData[slotIndex].push(x, y + h * 0.5, z, w, h);
}

let _lastBillboardYaw = null;

function tickBillboards() {
  _billboardProjMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
  _billboardFrustum.setFromProjectionMatrix(_billboardProjMatrix);

  const camYaw = pointerLock.euler.y;
  const faceY  = camYaw + Math.PI;
  const yawChanged = (faceY !== _lastBillboardYaw);

  // ---- Individual billboards (rocks, stumps, boxes) ----
  scatterGroup.children.forEach(m => {
    if (!m.userData.isBillboard) return;
    const inFrustum = _billboardFrustum.intersectsObject(m);
    m.visible = inFrustum;
    if (inFrustum && yawChanged) m.rotation.y = faceY;
  });

  // ---- Instanced veg â€” only rebuild matrices when camera rotates ----
  if (yawChanged) {
    _iQuat.setFromAxisAngle(_up, faceY);
    vegInstances.forEach((slot, si) => {
      const data = vegInstanceData[si];
      if (!data) return;
      const stride = 5; // x,y,z,w,h
      for (let i = 0; i < slot.count; i++) {
        const base = i * stride;
        _iPos.set(data[base], data[base+1], data[base+2]);
        _iScl.set(data[base+3], data[base+4], 1);
        _iMat.compose(_iPos, _iQuat, _iScl);
        slot.mesh.setMatrixAt(i, _iMat);
      }
      slot.mesh.instanceMatrix.needsUpdate = true;
    });
    _lastBillboardYaw = faceY;
  }
}

// ============================================================
//  SCENE JSON LOADER
// ============================================================
async function loadScene() {
  const res  = await fetch(SCENE_JSON);
  const data = await res.json();
  console.log('ðŸ“¦ Scene loaded. Buildings:', data.buildings.length, '| Waypoints:', data.waypoints.length);

  // Load sprite sheet textures â€” capture the promise so scatter can await it
  _spriteLoadPromise = loadSpriteAssets(data.assets);

  // Collect building positions for perimeter ring scatter
  data.buildings.forEach(b => {
    if (b.class !== 'terrain') {
      const [bx, by, bz] = b.position.split(' ').map(Number);
      // Compute world-space half-extents from scale (same 1.15 multiplier as loadBuildings)
      const [sx, sy, sz] = (b.scale||'1 1 1').split(' ').map(n => Number(n) * 1.15);
      // GLB models are typically unit-scale (~1Ã—1 footprint), scaled up by sx/sz
      // Half-extent = half the scale value gives a reasonable footprint estimate.
      // Tweak hx/hz per-building in the JSON if needed.
      const hx = sx * 0.55;   // half-width  (a little generous to overlap the base)
      const hz = sz * 0.55;   // half-depth
      buildingPositions.push({ x: bx, y: by, z: bz, hx, hz });
    }
  });

  data.waypoints.forEach(wp => {
    const [x,y,z] = wp.position.split(' ').map(Number);
    flightWaypoints.push(new YUKA.Vector3(x, y, z));
  });

  // Add tight orbit waypoints around each building so drones navigate close to geometry.
  // These sit just outside the building bounds at varying heights.
  const h = CONFIG.droneFlightHeight;
  data.buildings.forEach(b => {
    const [bx, by, bz] = b.position.split(' ').map(Number);
    const r = 6; // orbit radius â€” how close to hug the building
    // 4 points around each building at slightly different heights
    [
      [bx + r, h + 1,  bz    ],
      [bx,     h - 1,  bz + r],
      [bx - r, h + 2,  bz    ],
      [bx,     h,      bz - r],
    ].forEach(([wx, wy, wz]) => {
      flightWaypoints.push(new YUKA.Vector3(wx, wy, wz));
    });
  });

  loadBuildings(data);
  _sceneData = data; // keep reference for scatter
}

// ============================================================
//  MAIN LOOP
// ============================================================
let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;

  stepPhysics(dt);
  syncPhysicsReads();    // cache all Rapier reads â€” AFTER step
  queryPhysics();        // Three.js raycasts â€” no Rapier, safe anywhere

  const yukaD = yukaTime.update().getDelta();
  yukaManager.update(yukaD);

  tickPlayer(dt);
  tickLadders();
  tickDrones(dt);
  tickBullets(dt);
  tickBillboards();
  tickExplosions(dt);

  renderer.render(scene, camera);
}

// ============================================================
//  BOOT
// ============================================================
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

async function boot() {
  await initPhysics();
  initLadders();
  await loadScene();

  await sleep(500);
  initPlayer();

  document.getElementById('loading').classList.add('hidden');

  // Init audio on first user interaction
  const startAudio = async () => {
    await Tone.start();
    initAudio();
    document.removeEventListener('click', startAudio);
    document.removeEventListener('keydown', startAudio);
  };
  document.addEventListener('click', startAudio);
  document.addEventListener('keydown', startAudio);

  animate();
}

boot();
</script>
</body>
</html>