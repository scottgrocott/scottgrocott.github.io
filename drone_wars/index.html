<!DOCTYPE html>
<html>
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-EBGF4V165P"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-EBGF4V165P');
  </script>
  <meta charset="utf-8">
  <title>A-Frame Greybox Scene Build Date:2026-01-12 01:25:06</title>
  <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.0.0/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/yuka@0.7.8/build/yuka.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/howler@2.2.3/dist/howler.min.js"></script>
  <script type="module">
    // Import Rapier as ES module
    import RAPIER from 'https://scottgrocott.github.io/metal_throne/assets/js/rapier3d-compat/rapier.mjs';
    window.RAPIER = RAPIER;
  </script>
  <style>
    body { margin: 0; overflow: hidden; }
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-family: Arial, sans-serif;
      font-size: 24px;
      z-index: 1000;
      text-align: center;
    }
    #mobile-controls {
      position: fixed;
      bottom: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      z-index: 999;
      display: none;
    }
    #joystick-container {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 150px;
      height: 150px;
      z-index: 1001;
      touch-action: none;
    }
    .mobile-btn {
      position: fixed;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: rgba(212, 106, 40, 0.4);
      border: 2px solid #d46a28;
      color: white;
      z-index: 1001;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #btn-shoot { bottom: 120px; right: 40px; border-color: #a32e2e; background: rgba(163, 46, 46, 0.5); }
    #btn-interact { bottom: 40px; right: 40px; }
    @media (min-width: 992px) {
      #joystick-container, .mobile-btn { display: none; }
    }
    @media (max-width: 991px) { #mobile-controls { display: block; } }
  </style>
</head>
<body>
  <div id="loading">Loading...</div>
  <div id="mobile-controls">
    <div id="joystick-container"></div>
    <button id="btn-shoot" class="mobile-btn"><i class="bi bi-crosshair"></i></button>
    <button id="btn-interact" class="mobile-btn"><i class="bi bi-hand-index-thumb"></i></button>
  </div>
  
  <a-scene movement-controls="controls: joystick; speed:100" renderer="toneMapping: acesFilmic; exposure: 1.2; colorManagement: true" reflection>
    <a-sky color="#87CEEB" radius="10000"></a-sky>
    <a-light type="ambient" color="#BBB"></a-light>
    <a-light type="directional" color="#FFF" intensity="0.6" position="1 1 0"></a-light>
    <a-plane position="0 0 0" rotation="-90 0 0" width="10000" height="10000" color="tan" shadow physics-ground></a-plane>
    
    <a-assets id="asset-container" timeout="30000"></a-assets>
    
    <a-entity id="navmesh-container"></a-entity>
    <a-entity id="scene-container"></a-entity>
    
    <a-entity id="rig" position="0 1.6 0">
      <a-entity camera="far: 20000" look-controls="pointerLockEnabled: true" wasd-controls="acceleration: 100;fly: true" position="0 0 0"></a-entity>
    </a-entity>
  </a-scene>

  <script>
    const JSON_URL = 'https://scottgrocott.github.io/drone_wars/drone_wars_assets_dev.json';
    
    const yukaEntityManager = new YUKA.EntityManager();
    let physicsWorld;
    let physicsInitialized = false;

    async function initPhysics() {
      try {
        if (typeof window.RAPIER === 'undefined') {
          console.log('Waiting for RAPIER module to load...');
          setTimeout(initPhysics, 100);
          return;
        }
        
        console.log('Initializing RAPIER physics...');
        await window.RAPIER.init();
        
        const gravity = { x: 0.0, y: -9.81, z: 0.0 };
        physicsWorld = new window.RAPIER.World(gravity);
        
        physicsInitialized = true;
        console.log('Rapier physics initialized successfully!');
        window.RAPIER_READY = window.RAPIER;
        
        setInterval(() => {
          if (physicsWorld) physicsWorld.step();
        }, 16);
      } catch (error) {
        console.error('Failed to initialize Rapier:', error);
      }
    }

    window.addEventListener('load', initPhysics);

    AFRAME.registerComponent('spatial-sound', {
      schema: {
        src: { type: 'string', default: '' },
        volume: { type: 'number', default: 0.5 },
        loop: { type: 'boolean', default: true },
        refDistance: { type: 'number', default: 5 },
        maxDistance: { type: 'number', default: 50 },
        rolloffFactor: { type: 'number', default: 1 }
      },

      init: function() {
        this.sound = null;
        this.camera = null;
        
        if (!this.data.src) {
          console.warn('No sound source specified for spatial-sound');
          return;
        }
        
        // Create Howler sound with spatial audio
        this.sound = new Howl({
          src: [this.data.src],
          loop: this.data.loop,
          volume: this.data.volume,
          autoplay: true,
          spatial: true,
          refDistance: this.data.refDistance,
          maxDistance: this.data.maxDistance,
          rolloffFactor: this.data.rolloffFactor,
          onload: () => {
            console.log('ðŸ”Š Spatial sound loaded:', this.data.src);
          },
          onloaderror: (id, error) => {
            console.error('Failed to load sound:', error);
          }
        });
        
        // Get camera reference
        this.el.sceneEl.addEventListener('camera-set-active', (evt) => {
          this.camera = evt.detail.cameraEl;
        });
        
        // If camera already exists, use it
        setTimeout(() => {
          if (!this.camera) {
            this.camera = document.querySelector('[camera]');
          }
        }, 100);
      },

      tick: function() {
        if (!this.sound || !this.camera) return;
        
        // Update listener position (camera)
        const camPos = this.camera.object3D.position;
        const camRot = this.camera.object3D.rotation;
        
        Howler.pos(camPos.x, camPos.y, camPos.z);
        Howler.orientation(
          Math.sin(camRot.y), 0, -Math.cos(camRot.y),  // Forward vector
          0, 1, 0  // Up vector
        );
        
        // Update sound source position
        const pos = this.el.object3D.position;
        this.sound.pos(pos.x, pos.y, pos.z);
      },

      remove: function() {
        if (this.sound) {
          this.sound.stop();
          this.sound.unload();
        }
      }
    });

    AFRAME.registerComponent('physics-ground', {
      init: function() {
        const checkPhysics = () => {
          if (physicsInitialized && window.RAPIER_READY) {
            this.createGroundBody();
          } else {
            setTimeout(checkPhysics, 100);
          }
        };
        checkPhysics();
      },

      createGroundBody: function() {
        const R = window.RAPIER_READY;
        
        // Create static rigid body at ground level
        const rigidBodyDesc = R.RigidBodyDesc.fixed()
          .setTranslation(0, 0, 0);
        
        const rigidBody = physicsWorld.createRigidBody(rigidBodyDesc);
        
        // Create large flat collider (5000x5000 plane)
        const colliderDesc = R.ColliderDesc.cuboid(5000, 0.1, 5000)
          .setFriction(0.8)
          .setRestitution(0.1);
        
        physicsWorld.createCollider(colliderDesc, rigidBody);
        
        console.log('âœ… Ground physics collider created');
      }
    });

    AFRAME.registerComponent('physics-body', {
      schema: {
        type: { type: 'string', default: 'dynamic' },
        mass: { type: 'number', default: 1.0 },
        restitution: { type: 'number', default: 0.3 },
        friction: { type: 'number', default: 0.5 }
      },

      init: function() {
        this.rigidBody = null;
        this.collider = null;
        this.isDead = false;
        
        const checkPhysics = () => {
          if (physicsInitialized) {
            console.log('Physics body ready (will activate on kill event)');
          } else {
            setTimeout(checkPhysics, 100);
          }
        };
        checkPhysics();
        
        this.el.addEventListener('kill', () => {
          this.activatePhysics();
          this.el.removeAttribute('animation-mixer');
          this.el.removeAttribute('spatial-sound');
        });
      },

      activatePhysics: function() {
        if (this.isDead || !window.RAPIER_READY) return;
        
        const R = window.RAPIER_READY;
        
        console.log('ðŸ’¥ Activating physics - drone killed!');
        this.isDead = true;
        
        const pos = this.el.object3D.position;
        const rot = this.el.object3D.quaternion;
        
        const rigidBodyDesc = R.RigidBodyDesc.dynamic()
          .setTranslation(pos.x, pos.y, pos.z)
          .setRotation({ w: rot.w, x: rot.x, y: rot.y, z: rot.z });
        
        this.rigidBody = physicsWorld.createRigidBody(rigidBodyDesc);
        
        const colliderDesc = R.ColliderDesc.cuboid(0.5, 0.5, 0.5)
          .setMass(this.data.mass)
          .setRestitution(this.data.restitution)
          .setFriction(this.data.friction);
        
        this.collider = physicsWorld.createCollider(colliderDesc, this.rigidBody);
        
        this.rigidBody.setAngvel({ 
          x: (Math.random() - 0.5) * 10, 
          y: (Math.random() - 0.5) * 10, 
          z: (Math.random() - 0.5) * 10 
        }, true);
        
        if (this.el.components['yuka-nav']) {
          this.el.components['yuka-nav'].disableNavigation();
        }
        
        console.log('ðŸª¦ Drone is falling...');
      },

      tick: function() {
        if (!this.rigidBody || !this.isDead) return;
        
        const position = this.rigidBody.translation();
        const rotation = this.rigidBody.rotation();
        
        this.el.object3D.position.set(position.x, position.y, position.z);
        this.el.object3D.quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
      },

      remove: function() {
        if (this.collider && physicsWorld) {
          physicsWorld.removeCollider(this.collider);
        }
        if (this.rigidBody && physicsWorld) {
          physicsWorld.removeRigidBody(this.rigidBody);
        }
      }
    });

    AFRAME.registerComponent('yuka-nav', {
      schema: {
        speed: { type: 'number', default: 2 },
        patrolRadius: { type: 'number', default: 10 }
      },

      init: function() {
        this.vehicle = null;
        this.navigationActive = true;
        this.setupYukaVehicle();
      },

      setupYukaVehicle: function() {
        console.log('ðŸš Setting up Yuka vehicle...');
        
        this.el.addEventListener('model-loaded', () => {
          console.log('ðŸ“¦ Model loaded, creating Yuka vehicle');
          
          const pos = this.el.object3D.position;
          
          this.vehicle = new YUKA.Vehicle();
          this.vehicle.position.set(pos.x, pos.y, pos.z);
          this.vehicle.maxSpeed = this.data.speed;
          this.vehicle.updateOrientation = true;
          
          this.vehicle.syncToRenderComponent = (entity) => {
            this.el.object3D.position.copy(entity.position);
            this.el.object3D.quaternion.copy(entity.rotation);
          };
          
          yukaEntityManager.add(this.vehicle);
          
          console.log('âœ… Yuka vehicle created at:', this.vehicle.position);
          
          this.setupWanderBehavior();
        });
      },
      
      setupWanderBehavior: function() {
        console.log('ðŸ”§ Setting up wander behavior');
        
        const wanderBehavior = new YUKA.WanderBehavior();
        this.vehicle.steering.add(wanderBehavior);
        
        const obstacleBehavior = new YUKA.ObstacleAvoidanceBehavior();
        this.vehicle.steering.add(obstacleBehavior);
        
        console.log('âœ… Wander behavior active, behaviors:', this.vehicle.steering.behaviors.length);
      },

      tick: function(time, deltaTime) {
        if (this.vehicle && this.navigationActive) {
          const delta = deltaTime / 1000;
          yukaEntityManager.update(delta);
          
          if (this.vehicle.syncToRenderComponent) {
            this.vehicle.syncToRenderComponent(this.vehicle);
          }
        }
      },

      disableNavigation: function() {
        console.log('ðŸ›‘ Yuka navigation disabled');
        this.navigationActive = false;
        
        if (this.vehicle) {
          this.vehicle.steering.clear();
        }
      },

      remove: function() {
        if (this.vehicle) {
          yukaEntityManager.remove(this.vehicle);
        }
      }
    });

  AFRAME.registerComponent('modify-gltf-color', {
    schema: {
      color: {type: 'color', default: '#00FF00'}, // Default Green
      opacity: {type: 'number', default: 1.0}     // Default Opaque
    },

    init: function () {
      // Wait for the model to finish loading
      this.el.addEventListener('model-loaded', () => {
        
        // Get the underlying Three.js object
        const obj = this.el.getObject3D('mesh');
        
        // Go through every part of the model (in case it has children)
        obj.traverse((node) => {
          if (node.isMesh) {
            
            // OPTIONAL: Clone material so modifying one cube doesn't change ALL cubes
            // node.material = node.material.clone(); 

            // 1. Change RGB (Color)
            node.material.color.set(this.data.color);

            // 2. Change A (Alpha/Opacity)
            if (this.data.opacity < 1.0) {
              node.material.transparent = true; // Required for transparency to work
              node.material.opacity = this.data.opacity;
            }
          }
        });
      });
    }
  });


    async function loadScene() {
      try {
        const response = await fetch(JSON_URL);
        const data = await response.json();
        
        const assetContainer = document.querySelector('#asset-container');
        const sceneContainer = document.querySelector('#scene-container');
        const navmeshContainer = document.querySelector('#navmesh-container');
        
        data.assets.forEach(asset => {
          const assetItem = document.createElement('a-asset-item');
          assetItem.setAttribute('id', asset.id);
          assetItem.setAttribute('src', asset.src);
          assetContainer.appendChild(assetItem);
        });
        
        assetContainer.addEventListener('loaded', () => {
          document.querySelector('#loading').style.display = 'none';
        });
        
        data.buildings.forEach(building => {
          const entity = document.createElement('a-entity');
          entity.setAttribute('id', building.id);
          entity.setAttribute('gltf-model', building.model);
          entity.setAttribute('position', building.position);
          
          if (building.scale && building.scale !== "0 0 0") {
            entity.setAttribute('scale', building.scale);
          } else {
            entity.setAttribute('scale', '1 1 1');
          }
          
          if (building.rotation) {
            entity.setAttribute('rotation', building.rotation);
          } else {
            entity.setAttribute('rotation', '0 0 0');
          }
          
          entity.setAttribute('class', building.class);
          
          const navMeshEntity = document.createElement('a-entity');
          navMeshEntity.setAttribute('gltf-model', building.model);
          navMeshEntity.setAttribute('position', building.position);
          navMeshEntity.setAttribute('nav-mesh', '');
          navMeshEntity.setAttribute('visible', 'false');
          
          if (building.scale && building.scale !== "0 0 0") {
            navMeshEntity.setAttribute('scale', building.scale);
          } else {
            navMeshEntity.setAttribute('scale', '1 1 1');
          }
          
          if (building.rotation) {
            navMeshEntity.setAttribute('rotation', building.rotation);
          }
          
          navmeshContainer.appendChild(navMeshEntity);
          
          if (building.id === 'drone') {
/*
            entity.setAttribute('animation-mixer', 'clip: attack; loop: repeat; timeScale: 1');
            entity.setAttribute('yuka-nav', 'speed: 3; patrolRadius: 15');
            entity.setAttribute('physics-body', 'type: kinematic; mass: 2; restitution: 0.2; friction: 0.8');
            entity.setAttribute('spatial-sound', 'src: https://scottgrocott.github.io/metal_throne/assets/audio/buzz.mp3; volume: 0.7; refDistance: 5; maxDistance: 50');
*/
             buildDrone();
             /* 
            setTimeout(() => {
              console.log('â° Killing drone in 5 seconds...');
              setTimeout(() => {
                entity.emit('kill');
              }, 5000);
            }, 5000);*/
          }
          
          sceneContainer.appendChild(entity);
        });
        
        console.log('Scene loaded successfully!');
        
      } catch (error) {
        console.error('Error loading scene:', error);
        document.querySelector('#loading').textContent = 'Error loading scene. Check console for details.';
      }
    }
    
    window.addEventListener('load', loadScene);
   
    function buildDrone() {
      const sceneContainer = document.querySelector('#scene-container');
      const drone = document.createElement('a-entity');
      drone.setAttribute('id', 'drone');
      drone.setAttribute('gltf-model', '#droneglb');
      const color = getRandomRGB();
const rgbString = `rgb(${color.r}, ${color.g}, ${color.b})`;
      drone.setAttribute('modify-gltf-color', `color: ${rgbString}; opacity: 1.0`);
      drone.setAttribute('position', '0 2 0');
      drone.setAttribute('scale', '.5 .5 .5');
      drone.setAttribute('animation-mixer', 'clip: attack; loop: repeat; timeScale: 1');
      drone.setAttribute('yuka-nav', 'speed: 3; patrolRadius: 15');
      drone.setAttribute('physics-body', 'type: kinematic; mass: 2; restitution: 0.2; friction: 0.8');
      drone.setAttribute('spatial-sound', 'src: https://scottgrocott.github.io/metal_throne/assets/audio/buzz.mp3; volume: 0.7; refDistance: 5; maxDistance: 50');
        setTimeout(() => {
              console.log('â° Killing drone in 5 seconds...');
              setTimeout(() => {
                drone.emit('kill');
              }, 5000);
            }, 5000);
      
      sceneContainer.appendChild(drone);
    }

    /**
 * Returns an object with random red, green, and blue values (0-255).
 * @returns {{r: number, g: number, b: number}}
 */
function getRandomRGB() {
  return {
    r: Math.floor(Math.random() * 256),
    g: Math.floor(Math.random() * 256),
    b: Math.floor(Math.random() * 256)
  };
}
  </script>
</body>
</html>